<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Log4cplus 日志库]]></title>
    <url>%2F2020%2F11%2F22%2FLog4cplusLogLibrary%2F</url>
    <content type="text"><![CDATA[简介Log4cplus 是 log4j 的 C++ 实现，其接口和使用逻辑与 log4j 基本保持一致。 log4cplus 具有线程安全、灵活、以及多粒度控制的特点 可以通过将日志划分优先级使其可以面向程序调试、运行、测试、和维护等全生命周期 可以选择将日志输出到控制台、调试器、文件、服务器 可以通过指定策略对日志进行定期备份 许可协议Log4cplus 的每个文件是使用二级BSD许可协议（Two clause BSD license）或者 Apache license 2.0 许可协议，其中的线程池（ThreadPool.h）又是使用另外的协议。 重要组成 类 说明 Filter 过滤器，过滤输出消息 Layout 布局器，控制输出消息的格式 Appender 附加器，将日志输出到所附加的设备终端如控制台、调试器、文件、远程服务器等等 Logger 记录器，保存并跟踪对象日志信息变更的实体，当你需要对一个对象进行记录时，就需要生成一个logger Hierarchy 分类器，层次化的树型结构，用于对被记录信息的分类，层次中每一个节点维护一个logger的所有信息 LogLevel 优先权，包括TRACE, DEBUG, INFO, WARNING, ERROR, FATAL 关系 Hierarchy -&gt; Logger -&gt; Appender(Layout) -&gt; Filter InternalLoggingEvent -&gt; LogLevel 源码Filter过滤器，用于过滤日志项，可继承Filter自定义过滤器，也可用自带的过滤器 Filter DenyAllFilter：全部过滤 LogLevelMatchFilter：等级过滤 LogLevelRangeFilter：等级范围过滤 StringMatchFilter：字符串过滤 FunctionFilter：方法函数过滤 NDCMatchFilter MDCMatchFilter Layout布局器，控制输出日志消息的格式 Layout SimpleLayout: DEBUG - Hello world TTCCLayout(time、thread、category、context)：[0x60004b030] INFO SlowObject \ - Actually doing something PatternLayout class PatternLayout%%a – Abbreviated weekday name%%A – Full weekday name%%b – Abbreviated month name%%B – Full month name%%c – Standard date and time string%%d – Day of month as a decimal(1-31)%%H – Hour(0-23)%%I – Hour(1-12)%%j – Day of year as a decimal(1-366)%%m – Month as decimal(1-12)%%M – Minute as decimal(0-59)%%p – Locale’s equivalent of AM or PM%%q – milliseconds as decimal(0-999) – Log4CPLUS specific%%Q – fractional milliseconds as decimal(0-999.999) – Log4CPLUS specific%%S – Second as decimal(0-59)%%U – Week of year, Sunday being first day(0-53)%%w – Weekday as a decimal(0-6, Sunday being 0)%%W – Week of year, Monday being first day(0-53)%%x – Standard date string%%X – Standard time string%%y – Year in decimal without century(0-99)%%Y – Year including century as decimal%%Z – Time zone name%% – The percent sign 1new PatternLayout(LOG4CPLUS_TEXT("[%D&#123;%Y-%m-%d %H:%M:%S.%q&#125;] [%t] %-5p [%M] %m%n")); 1[2020-08-24 01:30:43.650] [14168] DEBUG [main] log test Appender附加器，将日志输出到所附加的设备终端如控制台、调试器、文件、远程服务器等等 class Appender12//! Asynchronous append.bool async; 12log4cplus::helpers::Properties properties;properties.setProperty(LOG4CPLUS_TEXT("AsyncAppend"), LOG4CPLUS_TEXT("true")); class AsyncAppender 1234log4cplus::helpers::Properties properties;log4cplus::SharedAppenderPtr fileAppend(new log4cplus::RollingFileAppender(properties));log4cplus::SharedAppenderPtr asyncAppender(new log4cplus::AsyncAppender(fileAppend, 100));m_logger.addAppender(asyncAppender); class RollingFileAppender123456RollingFileAppender(const log4cplus::tstring&amp; filename, long maxFileSize = 10*1024*1024, int maxBackupIndex = 1, bool immediateFlush = true, bool createDirs = false);RollingFileAppender(const log4cplus::helpers::Properties&amp; properties); Logger记录器，保存并跟踪对象日志信息变更的实体，当你需要对一个对象进行记录时，就需要生成一个logger 123456789101112void log(LogLevel ll, const log4cplus::tstring&amp; message, const char* file = LOG4CPLUS_CALLER_FILE (), int line = LOG4CPLUS_CALLER_LINE (), const char* function = LOG4CPLUS_CALLER_FUNCTION ()) const;void log(spi::InternalLoggingEvent const &amp;) const; void forcedLog(LogLevel ll, const log4cplus::tstring&amp; message, const char* file = LOG4CPLUS_CALLER_FILE (), int line = LOG4CPLUS_CALLER_LINE (), const char* function = LOG4CPLUS_CALLER_FUNCTION ()) const;void forcedLog(spi::InternalLoggingEvent const &amp;) const; Hierarchy分类器，层次化的树型结构，用于对被记录信息的分类，层次中每一个节点维护一个logger的所有信息 1234567typedef std::vector&lt;Logger&gt; ProvisionNode;typedef std::map&lt;log4cplus::tstring, ProvisionNode&gt; ProvisionNodeMap;typedef std::map&lt;log4cplus::tstring, Logger&gt; LoggerMap;ProvisionNodeMap provisionNodes;LoggerMap loggerPtrs;Logger root; LogLevel1typedef int LogLevel; 123456789const LogLevel OFF_LOG_LEVEL = 60000;const LogLevel FATAL_LOG_LEVEL = 50000;const LogLevel ERROR_LOG_LEVEL = 40000;const LogLevel WARN_LOG_LEVEL = 30000;const LogLevel INFO_LOG_LEVEL = 20000;const LogLevel DEBUG_LOG_LEVEL = 10000;const LogLevel TRACE_LOG_LEVEL = 0;const LogLevel ALL_LOG_LEVEL = TRACE_LOG_LEVEL;const LogLevel NOT_SET_LOG_LEVEL = -1; Properties属性，用于配置参数 12345678910log4cplus::helpers::Properties properties;properties.setProperty(LOG4CPLUS_TEXT("File"), logFile.c_str());properties.setProperty(LOG4CPLUS_TEXT("CreateDirs"), LOG4CPLUS_TEXT("true"));properties.setProperty(LOG4CPLUS_TEXT("ImmediateFlush"), LOG4CPLUS_TEXT("true"));properties.setProperty(LOG4CPLUS_TEXT("MaxFileSize"), std::to_wstring(max_file_size).c_str());properties.setProperty(LOG4CPLUS_TEXT("MaxBackupIndex"), std::to_wstring(max_file_count).c_str());properties.setProperty(LOG4CPLUS_TEXT("AsyncAppend"), s_async.c_str());properties.setProperty(LOG4CPLUS_TEXT("Locale"), LOG4CPLUS_TEXT("en_US.UTF-8"));log4cplus::SharedAppenderPtr fileAppend(new log4cplus::RollingFileAppender(properties)); 可变参数格式化打印日志示例1LOG4CPLUS_INFO(logger, LOG4CPLUS_TEXT("Hello world")); 原理LOG4CPLUS_INFO_FMT12#define LOG4CPLUS_INFO_FMT(logger, ...) \ LOG4CPLUS_MACRO_FMT_BODY (logger, INFO_LOG_LEVEL, __VA_ARGS__) LOG4CPLUS_MACRO_FMT_BODY1234567891011121314151617#define LOG4CPLUS_MACRO_FMT_BODY(logger, logLevel, ...) \ LOG4CPLUS_SUPPRESS_DOWHILE_WARNING() \ do &#123; \ log4cplus::Logger const &amp; _l \ = log4cplus::detail::macros_get_logger (logger); \ if (LOG4CPLUS_MACRO_LOGLEVEL_PRED ( \ _l.isEnabledFor (log4cplus::logLevel), logLevel)) &#123; \ LOG4CPLUS_MACRO_INSTANTIATE_SNPRINTF_BUF (_snpbuf); \ log4cplus::tchar const * _logEvent \ = _snpbuf.print (__VA_ARGS__); \ log4cplus::detail::macro_forced_log (_l, \ log4cplus::logLevel, _logEvent, \ LOG4CPLUS_MACRO_FILE (), __LINE__, \ LOG4CPLUS_MACRO_FUNCTION ()); \ &#125; \ &#125; while(0) \ LOG4CPLUS_RESTORE_DOWHILE_WARNING() LOG4CPLUS_MACRO_INSTANTIATE_SNPRINTF_BUF123# define LOG4CPLUS_MACRO_INSTANTIATE_SNPRINTF_BUF(var) \ log4cplus::helpers::snprintf_buf &amp; var \ = log4cplus::detail::get_macro_body_snprintf_buf () snprintf_buf::print12345678910111213141516171819tchar const *snprintf_buf::print (tchar const * fmt, ...)&#123; assert (fmt); tchar const * str = nullptr; int ret = 0; std::va_list args; do &#123; va_start (args, fmt); ret = print_va_list (str, fmt, args); va_end (args); &#125; while (ret == -1); return str;&#125; snprintf_buf::print_va_list12345678910111213141516171819202122232425262728293031323334353637383940414243intsnprintf_buf::print_va_list (tchar const * &amp; str, tchar const * fmt, std::va_list args)&#123; int printed; std::size_t const fmt_len = std::char_traits&lt;tchar&gt;::length (fmt); std::size_t buf_size = buf.size (); std::size_t const output_estimate = fmt_len + fmt_len / 2 + 1; if (output_estimate &gt; buf_size) buf.resize (buf_size = output_estimate);//... printed = vsntprintf (&amp;buf[0], buf_size - 1, fmt, args); if (printed == -1) &#123;#if defined (EILSEQ) if (errno == EILSEQ) &#123; LogLog::getLogLog ()-&gt;error ( LOG4CPLUS_TEXT ("Character conversion error when printing")); // Return zero to terminate the outer loop in // snprintf_buf::print(). return 0; &#125;#endif buf_size *= 2; buf.resize (buf_size); &#125; else if (printed &gt;= static_cast&lt;int&gt;(buf_size - 1)) &#123; buf_size = printed + 2; buf.resize (buf_size); printed = -1; &#125; else buf[printed] = 0;#endif str = &amp;buf[0]; return printed;&#125; 其实就是使用了C语音的可变参数宏实现参数可变 va_start va_arg va_end vadefs.h1234567#elif defined _M_IX86 &amp;&amp; !defined _M_HYBRID_X86_ARM64 #define _INTSIZEOF(n) ((sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1)) #define __crt_va_start_a(ap, v) ((void)(ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v))) #define __crt_va_arg(ap, t) (*(t*)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t))) #define __crt_va_end(ap) ((void)(ap = (va_list)0)) 使用了 _vswprintf_p（sprintf） 做格式化 12345678910int _vswprintf_p( wchar_t *buffer, size_t count, const wchar_t *format, va_list argptr);int sprintf ( char * str, const char * format, ... ); C语言的函数是从右往左压入栈的，比如一下内存分布 1234567891011121314void print_args(int count, ...) &#123; int i, value; va_list arg_ptr; va_start(arg_ptr, count); for(i=0; i&lt;count; i++) &#123; value = va_arg(arg_ptr,int); printf("position %d = %d\n", i+1, value); &#125; va_end(arg_ptr);&#125;int main(int argc, char* argv[]) &#123; print_args(5,1,2,3,4,5); return 0; &#125; 123456| 5 | // 高位地址| 4 || 3 || 2 || 1 | // arg_ptr| 5 | // count 日志打印流程流程 Logger::log LoggerImpl::log：等级 LoggerImpl::forcedLog：获取 InternalLoggingEvent LoggerImpl::callAppenders：遍历父子附加器 AppenderAttachableImpl::appendLoopOnAppenders：遍历附加器列表 Appender::doAppend：同步异步 Appender::syncDoAppend：检查阈值、过滤器、锁 FileAppenderBase::append：文件打开、锁定（进程同步）、格式化附加、刷新 SimpleLayout::formatAndAppend：附加 原理Logger::log123456voidLogger::log (LogLevel ll, const log4cplus::tstring&amp; message, const char* file, int line, const char* function) const&#123; value-&gt;log (ll, message, file, line, function ? function : "");&#125; LoggerImpl::log：等级1234567891011voidLoggerImpl::log(LogLevel loglevel, const log4cplus::tstring&amp; message, const char* file, int line, const char* function)&#123; if(isEnabledFor(loglevel)) &#123; forcedLog(loglevel, message, file, line, function ? function : ""); &#125;&#125; LoggerImpl::forcedLog：获取 InternalLoggingEvent12345678910111213voidLoggerImpl::forcedLog(LogLevel loglevel, const log4cplus::tstring&amp; message, const char* file, int line, const char* function)&#123; spi::InternalLoggingEvent &amp; ev = internal::get_ptd ()-&gt;forced_log_ev; assert (function); ev.setLoggingEvent (this-&gt;getName(), loglevel, message, file, line, function); callAppenders(ev);&#125; LoggerImpl::callAppenders：遍历父子附加器12345678910111213141516171819202122voidLoggerImpl::callAppenders(const InternalLoggingEvent&amp; event)&#123; int writes = 0; for(const LoggerImpl* c = this; c != nullptr; c=c-&gt;parent.get()) &#123; writes += c-&gt;appendLoopOnAppenders(event); if(!c-&gt;additive) &#123; break; &#125; &#125; // No appenders in hierarchy, warn user only once. if(!hierarchy.emittedNoAppenderWarning &amp;&amp; writes == 0) &#123; helpers::getLogLog().error( LOG4CPLUS_TEXT("No appenders could be found for logger (") + getName() + LOG4CPLUS_TEXT(").")); helpers::getLogLog().error( LOG4CPLUS_TEXT("Please initialize the log4cplus system properly.")); hierarchy.emittedNoAppenderWarning = true; &#125;&#125; AppenderAttachableImpl::appendLoopOnAppenders：遍历附加器列表123456789101112intAppenderAttachableImpl::appendLoopOnAppenders(const spi::InternalLoggingEvent&amp; event) const&#123; int count = 0; thread::MutexGuard guard (appender_list_mutex); for (auto &amp; appender : appenderList) &#123; ++count; appender-&gt;doAppend(event); &#125; return count;&#125; Appender::doAppend：同步异步1234567891011121314151617181920212223voidAppender::doAppend(const log4cplus::spi::InternalLoggingEvent&amp; event)&#123;#if ! defined (LOG4CPLUS_SINGLE_THREADED) if (async) &#123; event.gatherThreadSpecificData (); std::atomic_fetch_add_explicit (&amp;in_flight, std::size_t (1), std::memory_order_relaxed); try &#123; enqueueAsyncDoAppend (SharedAppenderPtr (this), event); &#125; catch (...) &#123; subtract_in_flight (); throw; &#125; &#125; else#endif syncDoAppend (event);&#125; Appender::syncDoAppend：检查阈值、过滤器、锁123456789101112131415161718192021222324252627282930313233voidAppender::syncDoAppend(const log4cplus::spi::InternalLoggingEvent&amp; event)&#123; thread::MutexGuard guard (access_mutex); if(closed) &#123; helpers::getLogLog().error( LOG4CPLUS_TEXT("Attempted to append to closed appender named [") + name + LOG4CPLUS_TEXT("].")); return; &#125; // Check appender's threshold logging level. if (! isAsSevereAsThreshold(event.getLogLevel())) return; // Evaluate filters attached to this appender. if (checkFilter(filter.get(), event) == spi::DENY) return; // Lock system wide lock. helpers::LockFileGuard lfguard; if (useLockFile &amp;&amp; lockFile.get ()) &#123; try &#123; lfguard.attach_and_lock (*lockFile); &#125; catch (std::runtime_error const &amp;) &#123; return; &#125; &#125; // Finally append given event. append(event);&#125; FileAppenderBase::append：文件打开、锁定（进程同步）、格式化附加、刷新12345678910111213141516171819202122voidFileAppenderBase::append(const spi::InternalLoggingEvent&amp; event)&#123; if(!out.good()) &#123; if(!reopen()) &#123; getErrorHandler()-&gt;error( LOG4CPLUS_TEXT("file is not open: ") + filename); return; &#125; // Resets the error handler to make it // ready to handle a future append error. else getErrorHandler()-&gt;reset(); &#125; if (useLockFile) out.seekp (0, std::ios_base::end); layout-&gt;formatAndAppend(out, event); if(immediateFlush || useLockFile) out.flush();&#125; SimpleLayout::formatAndAppend：附加123456789voidSimpleLayout::formatAndAppend(log4cplus::tostream&amp; output, const log4cplus::spi::InternalLoggingEvent&amp; event)&#123; output &lt;&lt; llmCache.toString(event.getLogLevel()) &lt;&lt; LOG4CPLUS_TEXT(" - ") &lt;&lt; event.getMessage() &lt;&lt; LOG4CPLUS_TEXT("\n");&#125; 源码编译默认编译编译成动态库，带有很多例子项目 去除例子（只编译库）修改记录https://github.com/huihut/log4cplus/commit/5d7e51ac6a43e1eaa623e5d2272651458edf85c6 修改内容./CMakeLists.txt 1234option(LOG4CPLUS_BUILD_TESTING "Build the test suite." OFF)option(LOG4CPLUS_BUILD_LOGGINGSERVER "Build the logging server." OFF)...option(WITH_UNIT_TESTS "Enable unit tests" OFF) 编译成静态库修改记录https://github.com/huihut/log4cplus/commit/4e02f06a5549afca1183801a1424eee221a36bb5 修改内容./src/CMakeLists.txt 123add_compile_definitions (LOG4CPLUS_STATIC)...add_library ($&#123;log4cplus&#125; STATIC $&#123;log4cplus_sources&#125;) 使用将日志输出到控制台1234567891011121314151617181920212223242526#include &lt;log4cplus/log4cplus.h&gt; int main()&#123; //用Initializer类进行初始化 log4cplus::Initializer initializer; //第1步：创建ConsoleAppender log4cplus::SharedAppenderPtr appender(new log4cplus::ConsoleAppender()); //第2步：设置Appender的名称和输出格式（SimpleLayout） appender-&gt;setName(LOG4CPLUS_TEXT("console")); appender-&gt;setLayout(std::unique_ptr&lt;log4cplus::Layout&gt;(new log4cplus::SimpleLayout)); //第3步：获得一个Logger实例，并设置其日志输出等级阈值 log4cplus::Logger logger = log4cplus::Logger::getInstance(LOG4CPLUS_TEXT ("test")); logger.setLogLevel(log4cplus::INFO_LOG_LEVEL); //第4步：为Logger实例添加ConsoleAppender logger.addAppender(appender); //第5步：使用宏将日志输出 LOG4CPLUS_INFO(logger, LOG4CPLUS_TEXT("Hello world")); return 0;&#125; 将日志输出到控制台并写入文件123456789101112131415161718192021222324252627282930313233343536#include &lt;log4cplus/log4cplus.h&gt; int main()&#123; //用Initializer类进行初始化 log4cplus::Initializer initializer; //第1步：创建ConsoleAppender和FileAppender(参数app表示内容追加到文件) log4cplus::SharedAppenderPtr consoleAppender(new log4cplus::ConsoleAppender); log4cplus::SharedAppenderPtr fileAppender(new log4cplus::FileAppender( LOG4CPLUS_TEXT("log.txt"), std::ios_base::app)); //第2步：设置Appender的名称和输出格式 //ConsoleAppender使用SimpleLayout //FileAppender使用PatternLayout consoleAppender-&gt;setName(LOG4CPLUS_TEXT("console")); consoleAppender-&gt;setLayout(std::unique_ptr&lt;log4cplus::Layout&gt;(new log4cplus::SimpleLayout())); fileAppender-&gt;setName(LOG4CPLUS_TEXT("file")); log4cplus::tstring pattern = LOG4CPLUS_TEXT("%D&#123;%m/%d/%y %H:%M:%S,%Q&#125; [%t] %-5p %c - %m [%l]%n"); fileAppender-&gt;setLayout(std::unique_ptr&lt;log4cplus::Layout&gt;(new log4cplus::PatternLayout(pattern))); //第3步：获得一个Logger实例，并设置其日志输出等级阈值 log4cplus::Logger logger = log4cplus::Logger::getInstance(LOG4CPLUS_TEXT ("test")); logger.setLogLevel(log4cplus::INFO_LOG_LEVEL); //第4步：为Logger实例添加ConsoleAppender和FileAppender logger.addAppender(consoleAppender); logger.addAppender(fileAppender); //第5步：使用宏将日志输出 LOG4CPLUS_INFO(logger, LOG4CPLUS_TEXT("Hello world")); return 0;&#125; log4cplusplushttps://github.com/huihut/log4cplusplus 简介log4cplusplus 是 log4cplus 的包装库 线程安全 支持异步 支持中文路径和内容 支持输出到文件、控制台、调试器 支持格式化打印 接口1234567891011121314151617181920212223242526272829303132333435363738enum Log4CPlusPlusLevel&#123; LogDebugLevel = 10000, LogInfoLevel = 20000, LogWarnLevel = 30000, LogErrorLevel = 40000&#125;;class Log4CPlusPlus&#123;public: Log4CPlusPlus() &#123;&#125; virtual ~Log4CPlusPlus() &#123;&#125;public: virtual void Release() = 0; virtual void AddFileAppender( const wchar_t *file_path = DEFALT_LOG_FILE_PATH, const wchar_t *file_name = DEFALT_LOG_FILE_NAME, unsigned long max_file_size = DEFALT_MAX_FILE_SIZE, unsigned long max_file_count = DEFALT_MAX_FILE_COUNT, bool is_async = DEFALT_IS_ASYNC ) = 0; virtual void EnableDebuggerAppender(bool enable) = 0; virtual void EnableConsoleAppender(bool enable) = 0; virtual const wchar_t * GetLogPath() = 0; virtual void WriteLog( Log4CPlusPlusLevel logLevel, const char* file, int line, const char* function, const wchar_t *format, ...) = 0;&#125;; 使用123456789101112131415161718192021#include "log4cplusplus.h"int main(int argc, char *argv[])&#123; log4cplus::Log4CPlusPlus* log = CreateLog4CPlusPlus(); if (log) &#123; log-&gt;AddFileAppender(); log-&gt;EnableDebuggerAppender(true); log-&gt;EnableConsoleAppender(true); LOG4CPLUSPLUS_DEBUG(log, L"log test"); LOG4CPLUSPLUS_INFO(log, L"log test %s", L"info"); LOG4CPLUSPLUS_WARN(log, L"log test %s %d", L"warn", 123); LOG4CPLUSPLUS_ERROR(log, L"log test %f", 3.14); LOG4CPLUSPLUS_ERROR(log, L"中文日志测试!!"); log-&gt;Release(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows编译构建CEF发行版]]></title>
    <url>%2F2020%2F03%2F07%2FWindowsBuildCEF%2F</url>
    <content type="text"><![CDATA[下载在 CEF 发行版网站（Chromium Embedded Framework (CEF) Automated Builds）下载对应的 Standard Distribution 版本，本文以 CEF 75.1.14（cef_binary_75.1.8+g84fed5d+chromium-75.0.3770.100_windows32.tar.bz2）为例 使用 CMake 构建打开 cmake-gui，设置源码和生成路径： Where is the source code: D:/code/git/cef-builds/cef_binary_75.1.14+gc81164e+chromium-75.0.3770.100_windows32 Where to build the binaries: D:/code/git/cef-builds/cef_binary_75.1.14+gc81164e+chromium-75.0.3770.100_windows32/build 点击 Configure 生成配置，修改： 生成动态库（个人偏好）：CEF_RUNTIME_LIBRARY_FLAG 从 /MT 改为 /MD 不用沙盒（原因见 这里）：不勾选 USE_SANDBOX 点击 Configure、Generate 生成 VS 工程 使用 VS 编译ceftests 项目会有文件格式错误123456781&gt;------ 已启动生成: 项目: ceftests, 配置: Debug Win32 ------1&gt;os_rendering_unittest.cc1&gt;D:\code\git\cef-builds\cef_binary_75.1.14+gc81164e+chromium-75.0.3770.100_windows32\tests\ceftests\os_rendering_unittest.cc(794): error C2220: 警告被视为错误 - 没有生成“object”文件1&gt;D:\code\git\cef-builds\cef_binary_75.1.14+gc81164e+chromium-75.0.3770.100_windows32\tests\ceftests\os_rendering_unittest.cc(794): warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失1&gt;D:\code\git\cef-builds\cef_binary_75.1.14+gc81164e+chromium-75.0.3770.100_windows32\tests\ceftests\os_rendering_unittest.cc(955): error C2001: 常量中有换行符1&gt;D:\code\git\cef-builds\CEF 79.1.38\cef_binary_75.1.14+gc81164e+chromium-75.0.3770.100_windows32\tests\ceftests\os_rendering_unittest.cc(998): error C2001: 常量中有换行符1&gt;D:\code\git\cef-builds\cef_binary_75.1.14+gc81164e+chromium-75.0.3770.100_windows32\tests\ceftests\os_rendering_unittest.cc(998): fatal error C1075: “&#123;”: 未找到匹配令牌1&gt;已完成生成项目“ceftests.vcxproj”的操作 - 失败。 用记事本打开 os_rendering_unittest.cc 文件，另存为 带有 BOM 的 UTF-8 编码，覆盖原文件。 重新编译则会编译通过。 然后设置 cefclient 为启动项目，F5，则可看到 Google 为主页的一个浏览器 Demo]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CEF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个基于 C# 的简单的线程安全日志模块]]></title>
    <url>%2F2019%2F07%2F28%2FLogConsumer%2F</url>
    <content type="text"><![CDATA[一个基于 C# 的简单的线程安全日志模块，它使用生产者 - 消费者模式，可以在 .NET Framework 和 .Net Core 中使用。 Github 地址：LogConsumer 使用 将 LogConsumer.cs 添加到你的项目中 将 LogConsumer.cs 中的 logFileName 修改为你的路径文件名 在需要输出日志的地方使用它 1HuiHut.LogConsumer.LogConsumer.Instance.Write("your log content"); 编译运行 命令行 12dotnet builddotnet .\LogConsumer\bin\Debug\netcoreapp2.1\LogConsumer.dll Visual Studio 打开 LogConsumer.sln 生成解决方案，运行测试 测试的日志文件示例10 个线程，每个线程抛出 10 条日志的测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112Data Time Namespace Class Method LogContent----------------------------------------------------------------------------------2019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 5 ] index = 02019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 2 ] index = 02019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 7 ] index = 02019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 4 ] index = 02019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 3 ] index = 02019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 6 ] index = 02019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 0 ] index = 02019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 1 ] index = 02019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 9 ] index = 02019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 8 ] index = 02019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 2 ] index = 12019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 7 ] index = 12019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 5 ] index = 12019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 5 ] index = 22019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 3 ] index = 12019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 6 ] index = 12019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 0 ] index = 12019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 1 ] index = 12019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 2 ] index = 22019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 9 ] index = 12019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 5 ] index = 32019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 3 ] index = 22019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 6 ] index = 22019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 7 ] index = 22019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 8 ] index = 12019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 4 ] index = 12019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 0 ] index = 22019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 1 ] index = 22019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 2 ] index = 32019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 9 ] index = 22019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 5 ] index = 42019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 3 ] index = 32019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 6 ] index = 32019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 7 ] index = 32019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 8 ] index = 22019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 4 ] index = 22019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 0 ] index = 32019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 1 ] index = 32019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 2 ] index = 42019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 9 ] index = 32019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 5 ] index = 52019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 3 ] index = 42019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 6 ] index = 42019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 7 ] index = 42019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 8 ] index = 32019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 4 ] index = 32019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 0 ] index = 42019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 1 ] index = 42019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 2 ] index = 52019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 9 ] index = 42019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 5 ] index = 62019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 3 ] index = 52019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 6 ] index = 52019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 7 ] index = 52019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 8 ] index = 42019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 4 ] index = 42019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 0 ] index = 52019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 1 ] index = 52019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 2 ] index = 62019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 9 ] index = 52019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 5 ] index = 72019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 3 ] index = 62019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 6 ] index = 62019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 7 ] index = 62019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 8 ] index = 52019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 4 ] index = 52019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 0 ] index = 62019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 1 ] index = 62019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 2 ] index = 72019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 9 ] index = 62019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 5 ] index = 82019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 3 ] index = 72019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 6 ] index = 72019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 7 ] index = 72019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 8 ] index = 62019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 4 ] index = 62019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 0 ] index = 72019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 1 ] index = 72019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 2 ] index = 82019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 9 ] index = 72019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 5 ] index = 92019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 3 ] index = 82019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 6 ] index = 82019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 7 ] index = 82019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 8 ] index = 72019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 4 ] index = 72019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 0 ] index = 82019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 1 ] index = 82019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 2 ] index = 92019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 9 ] index = 82019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 5 ] Thread is finished.2019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 3 ] index = 92019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 6 ] index = 92019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 7 ] index = 92019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 8 ] index = 82019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 4 ] index = 82019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 0 ] index = 92019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 1 ] index = 92019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 2 ] Thread is finished.2019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 9 ] index = 92019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 3 ] Thread is finished.2019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 6 ] Thread is finished.2019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 7 ] Thread is finished.2019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 8 ] index = 92019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 4 ] index = 92019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 0 ] Thread is finished.2019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 1 ] Thread is finished.2019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 9 ] Thread is finished.2019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 8 ] Thread is finished.2019-05-10 01:50:09 HuiHut.LogConsumer:LogConsumerTest.WriteLog [ 4 ] Thread is finished.]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Dotnet</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取 Windows 操作系统的系统、网络、硬件、软件等信息]]></title>
    <url>%2F2019%2F07%2F28%2FGetWindowsInfo%2F</url>
    <content type="text"><![CDATA[Github 源码：WindowsInfo.Net 可执行文件：WindowsInfo.Net.exe 获取的信息能获得的信息如下（系统、硬件、网络信息已打码） 123456789101112131415161718192021222324252627282930313233343536373839404142--------- 系统信息 ---------计算机名：***登录用户名：***操作系统类型：***--------- 硬件信息 ---------本机的MAC地址：***主板序列号：***主板制造厂商：***主板编号：***主板编号：***主板型号：***CPU序列号：***CPU编号：***CPU版本信息：***CPU名称信息：***CPU制造厂商：***物理硬盘序列号：***磁盘序列号：***网卡地址：***网卡硬件地址：***物理内存：***显卡PNPDeviceID：***声卡PNPDeviceID：***--------- 网络信息 ---------IP地址：***本地ip地址：***本地ip地址：***外网ip地址：***外网ip地址：***--------- 软件信息 ---------GitHub Desktop 2.1.0Mozilla Firefox 68.0 (x86 en-US) 68.0Microsoft OneDrive 19.103.0527.0003Python 3.7.2 (32-bit) 3.7.2150.0Microsoft Visual Studio Code (User) 1.36.1*** 硬件网络信息硬件网络信息是通过 System.Management 里面的类方法获取的，具体类方法可查看官方文档： System.Management Namespace 软件信息软件信息是通过读取注册表的方式获取的，所以软件开发使用的话需要验证一下某些安全管家是否会警告。 都有的信息：名字（DisplayName） 大部分都有的信息：名字（DisplayName）、版本号（DisplayVersion）、发行商（Publisher）、安装日期（InstallDate） 比较多信息的如下图： 软件信息在注册表的路径12计算机\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Uninstall\计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ 监控读取注册表测试了一下读取注册表，360，腾讯管家不会警告，但有些软件（如：procmon）能监控进程的读取的行为。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Dotnet</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D 编辑器调试无响应问题]]></title>
    <url>%2F2019%2F05%2F17%2FUnity3DEditorDebuggingNoResponse%2F</url>
    <content type="text"><![CDATA[问题描述使用 VS 在 Unity 编辑器中调试代码，点击 VS 的 附加到 Unity，Unity 编辑器按下 Play 之后，就会一直等待并且无其他响应，只能结束 Unity 进程。 原因分析经过分析与测试，发现去掉代码中一个单例类的析构方法中的断点即可调试了，具体原因未知。 再测试了一下，在那个单例类的构造、析构方法中分别打断点，如下表： 测试 构造 析构 结果 1 可调试 2 * 可调试 3 * 无响应 4 * * 无响应 表中 * 代表打断点 可发现只要在那个单例类的析构中打断点就会造成 Unity 无响应。 解决办法删除析构方法中的断点，或者所有断点，再调试。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python DeprecationWarning the imp module is deprecated in favour of importlib]]></title>
    <url>%2F2019%2F01%2F21%2FPythonDeprecationWarningTheImpModuleIsDeprecatedInFavourOfImportlib%2F</url>
    <content type="text"><![CDATA[报错12E:\PyCharm 2018.2.5\helpers\pycharm\docrunner.py:1: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module&apos;s documentation for alternative uses import imp 原因imp 从 Python 3.4 之后弃用了，建议使用 importlib 代替 解决打开 E:\PyCharm 2018.2.5\helpers\pycharm\docrunner.py 文件，做如下两步修改： 在第一行，注释掉 imp，导入 importlib 12#import impimport importlib 在第 230 行的 loadSource 函数中，注释 imp.load_source，使用 importlib.machinery.SourceFileLoader 加载模块 12#module = imp.load_source(moduleName, fileName)module = importlib.machinery.SourceFileLoader(moduleName, fileName).load_module()]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 下源码编译 eos 人脸模型拟合库过程遇到的坑坑坑]]></title>
    <url>%2F2019%2F01%2F13%2FCompileEOSOnWindows%2F</url>
    <content type="text"><![CDATA[eos 是一个用现代 C++11/14 编写的轻量级三维形变人脸模型拟合库，下面介绍下编译它的步骤和遇到的一些坑坑坑坑！ 博文的前半部分是用手动安装的 opencv 和 boost 构建和编译的，一路是坑，最终没有编译成功； 博文的后半部分是用 vcpkg 构建系统安装的 opencv 和 boost 然后构建和编译的，最终编译成功，但是运行失败。 至今为止，关于运行失败的 issue 作者也没有回复，希望有朝一日能填坑吧~ 初期编译环境 Windows 10 Visual Studio 2017 CMake 3.12.4 OpenCV 4.0.1 Boost 1.66.0 克隆配置12git clone --recursive git@github.com:patrikhuber/eos.gitmkdir eos_build 打开 CMake-gui，设置 Where is the source code: D:/code/VS/BabyCreator/eos Where to build the binaries: D:/code/VS/BabyCreator/eos_build 点击 Configure，设置编译器 Specify the generator for this project: Visual Studio 15 2017 Finish 配置过程遇到如下错误。 Found OpenCV Windows Pack but it has no binaries compatible with your configuration. 错误问题12345Found OpenCV Windows Pack but it has no binaries compatible with yourconfiguration.You should manually point CMake variable OpenCV_DIR to your build of OpenCVlibrary. 原因能找到 OpenCV 路径，但找不到兼容的二进制文件。 出错的这个 OpenCV 是在 opencv.org/releases 下载的 Win pack。 尝试过网友的解决方案【尝试二、三、四】都不能解决，最终通过【尝试五】重新下载源码编译解决，因此可能是构建环境或者编译器的问题。 解决【尝试一】重新设置环境变量：E:\opencv-4.0.1\opencv-4.0.1-winpack\opencv\build\x64\vc15\bin 【尝试二】在 eos/CMakeCache.txt 设置 OpenCV_DIR，不行。 12set(OpenCV_DIR &quot;D:\\code\\VS\\BabyCreator\\eos\\3rdparty\\opencv\\build&quot;)find_package(OpenCV REQUIRED) 【尝试三】在终端设置 OpenCV_DIR，不行。 1PS D:\code\VS\BabyCreator\eos&gt; cmake . -DOpenCV_DIR=D:\\code\\VS\\BabyCreator\\eos\\3rdparty\\opencv\\build\\OpenCVConfig.cmake 【尝试四】在 find_package 前设置 OpenCV_FOUND 为 1，不行。 12set(OpenCV_FOUND 1)find_package(OpenCV REQUIRED) 【尝试五】下载源码编译 VS 2017 工程的 opencv，解决。 在 CMake Configure、Generate 在 VS ALL_BUILD、INSTALL 执行 install/setup_vars_opencv4.cmd 设置环境变量：E:/opencv-4.0.1/opencv-4.0.1-vs-build/install/x86/vc15/bin Imported targets and dependency information not available for Boost version 错误123456789101112131415161718CMake Warning at E:/CMake/share/cmake-3.12/Modules/FindBoost.cmake:577 (message): Imported targets and dependency information not available for Boost version (all versions older than 1.33)Call Stack (most recent call first): E:/CMake/share/cmake-3.12/Modules/FindBoost.cmake:963 (_Boost_COMPONENT_DEPENDENCIES) E:/CMake/share/cmake-3.12/Modules/FindBoost.cmake:1622 (_Boost_MISSING_DEPENDENCIES) examples/CMakeLists.txt:22 (find_package)......Boost found at Boost_INCLUDE_DIR-NOTFOUNDCMake Error: The following variables are used in this project, but they are set to NOTFOUND.Please set them or make sure they are set and tested correctly in the CMake files:D:/code/VS/BabyCreator/eos/examples/Boost_INCLUDE_DIR used as include directory in directory D:/code/VS/BabyCreator/eos/examples used as include directory in directory D:/code/VS/BabyCreator/eos/examples used as include directory in directory D:/code/VS/BabyCreator/eos/examples used as include directory in directory D:/code/VS/BabyCreator/eos/examplesConfiguring incomplete, errors occurred! 原因没找到 Boost 库，原因是没配置好。 解决尝试了如下方式后，这个问题变成了 Unable to find the requested Boost libraries. 下载 boost 运行 boost_1_66_0/b2.exe 生成静态库 在 eos/CMakeCache.txt 配置 12set(BOOST_ROOT &quot;E:\\boost_1_66_0&quot;)set(BOOST_LIBRARYDIR $&#123;BOOST_ROOT&#125;/stage/lib) Unable to find the requested Boost libraries. 错误12345678910111213141516171819202122CMake Error at E:/CMake/share/cmake-3.12/Modules/FindBoost.cmake:2048 (message): Unable to find the requested Boost libraries. Boost version: 1.66.0 Boost include path: E:/boost_1_66_0 Could not find the following Boost libraries: boost_system boost_filesystem boost_program_options No Boost libraries were found. You may need to set BOOST_LIBRARYDIR to the directory containing Boost libraries or BOOST_ROOT to the location of Boost.Call Stack (most recent call first): examples/CMakeLists.txt:22 (find_package)Boost found at E:/boost_1_66_0Configuring incomplete, errors occurred! 原因找到了 Boost 库，但是找不到 boost_system、boost_filesystem、boost_program_options 这三个库。 解决这个问题太坑了，最终是把 E:\boost_1_66_0\stage\lib 里面的那三个库（每个有四个相关库）的名字分别删掉 lib，如下对 boost_system 的修改： libboost_system-vc141-mt-x32-1_66.lib 改为 boost_system-vc141-mt-x32-1_66.lib libboost_system-vc141-mt-gd-x32-1_66.lib 改为 boost_system-vc141-mt-gd-x32-1_66.lib libboost_system-vc141-mt-x64-1_66.lib 改为 boost_system-vc141-mt-x64-1_66.lib libboost_system-vc141-mt-gd-x64-1_66.lib 改为 boost_system-vc141-mt-gd-x64-1_66.lib 现在终于可以生成工程文件了！ 然而 VS 打开工程后编译，又有问题。 error C2065: “CV_BGR2BGRA”: 未声明的标识符generate-obj.vcxproj1eos\include\eos\render\texture.hpp(101): error C2065: “CV_BGR2BGRA”: 未声明的标识符 (undeclared identifier) 解决这个问题可以根据这个 issue，把 CV_BGR2BGRA 改为 cv::COLOR_BGR2BGRA，或者改为 0 解决。 error LNK2005: xxx 已经在 xxx 中定义；error LNK2019: 无法解析的外部符号fit-model-simple.vcxproj123456781&gt;boost_program_options-vc140-mt-gd.lib(boost_program_options-vc141-mt-gd-x32-1_68.dll) : error LNK2005: &quot;public: __thiscall boost::program_options::value_semantic_codecvt_helper&lt;char&gt;::value_semantic_codecvt_helper&lt;char&gt;(void)&quot; (??0?$value_semantic_codecvt_helper@D@program_options@boost@@QAE@XZ) 已经在 boost_program_options-vc141-mt-gd-x32-1_66.lib(value_semantic.obj) 中定义1&gt;boost_program_options-vc140-mt-gd.lib(boost_program_options-vc141-mt-gd-x32-1_68.dll) : error LNK2005: &quot;public: virtual __thiscall boost::program_options::value_semantic_codecvt_helper&lt;char&gt;::~value_semantic_codecvt_helper&lt;char&gt;(void)&quot; (??1?$value_semantic_codecvt_helper@D@program_options@boost@@UAE@XZ) 已经在 boost_program_options-vc141-mt-gd-x32-1_66.lib(value_semantic.obj) 中定义1&gt;boost_program_options-vc140-mt-gd.lib(boost_program_options-vc141-mt-gd-x32-1_68.dll) : error LNK2005: &quot;void __cdecl boost::program_options::validate(class boost::any &amp;,class std::vector&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;,class std::allocator&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &gt; &gt; const &amp;,class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; *,int)&quot; (?validate@program_options@boost@@YAXAAVany@2@ABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@H@Z) 已经在 boost_program_options-vc141-mt-gd-x32-1_66.lib(value_semantic.obj) 中定义1&gt;boost_program_options-vc140-mt-gd.lib(boost_program_options-vc141-mt-gd-x32-1_68.dll) : error LNK2005: &quot;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; __cdecl boost::program_options::to_internal(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; const &amp;)&quot; (?to_internal@program_options@boost@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z) 已经在 boost_program_options-vc141-mt-gd-x32-1_66.lib(convert.obj) 中定义1&gt; 正在创建库 D:/code/VS/BabyCreator/eos_build/examples/Debug/fit-model-simple.lib 和对象 D:/code/VS/BabyCreator/eos_build/examples/Debug/fit-model-simple.exp1&gt;fit-model-simple.obj : error LNK2019: 无法解析的外部符号 &quot;class cv::Mat __cdecl cv::imread(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; const &amp;,int)&quot; (?imread@cv@@YA?AVMat@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z)，该符号在函数 __catch$_main$0 中被引用1&gt;fit-model-simple.obj : error LNK2019: 无法解析的外部符号 &quot;bool __cdecl cv::imwrite(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; const &amp;,class cv::debug_build_guard::_InputArray const &amp;,class std::vector&lt;int,class std::allocator&lt;int&gt; &gt; const &amp;)&quot; (?imwrite@cv@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV_InputArray@debug_build_guard@1@ABV?$vector@HV?$allocator@H@std@@@3@@Z)，该符号在函数 __catch$_main$6 中被引用1&gt;D:\code\VS\BabyCreator\eos_build\examples\Debug\fit-model-simple.exe : fatal error LNK1120: 2 个无法解析的外部命令 原因这个问题可能是安装的这个版本的 boost 库与什么东西不兼容吧，又是环境问题，我已经无力吐槽 Windows 了（心累）。 解决这个问题我在官方仓库提了个 issue。 作者的意思是：我没试过你的 boost 和 opencv 的版本，可能是本地配置问题，建议用构建系统（如 vcpkg） 或者在 StackOverflow 上提问。 我：emmm…… 所以，这个问题未解决，最后是用 vcpkg 安装库解决的。 再次编译环境 Windows 10 Visual Studio 2017 CMake 3.12.4 OpenCV 3.4.3 Boost 1.68.0 vcpkg 2018.11.23-nohash vcpkg 配置安装安装 vcpkg、opencv、boost1234git clone https://github.com/Microsoft/vcpkg.gitcd vcpkg.\bootstrap-vcpkg.bat.\vcpkg install opencv boost 安装完成后，在 eos 同级目录下创建 build 文件夹 eos_vcpkg_build，如下目录结构： 1234567- eos - CMakeLists.txt - ...- eos_vcpkg_build - install - eos.sln - ... 然后执行下面的命令构建工程： 123mkdir eos_vcpkg_buildcd eos_vcpkg_buildcmake ../eos -DOpenCV_DIR=D:\\code\\git\\vcpkg\\buildtrees\\opencv\\x86-windows-rel -DBOOST_ROOT=D:\\code\\git\\vcpkg\\installed\\x86-windows\\bin -DBOOST_LIBRARYDIR=D:\\code\\git\\vcpkg\\installed\\x86-windows\\bin -DBOOST_INCLUDEDIR=D:\\code\\git\\vcpkg\\installed\\x86-windows\\include -DCMAKE_INSTALL_PREFIX=install/ OpenCV_DIR 设为 vcpkg 安装的 opencv 路径 BOOST_ROOT 设为 vcpkg 安装的 boost 路径 BOOST_LIBRARYDIR 设为 vcpkg 安装的 boost 库文件路径 BOOST_INCLUDEDIR 设为 vcpkg 安装的 boost 头文件路径 CMAKE_INSTALL_PREFIX 即为 make install 的路径 构建好后，用 VS 打开，右键 解决方案 eos - 生成解决方案 然后选择 INSTALL 工程 - 右键 设为启动项目 - 右键 生成 居然成功编译并安装好了（喜极而泣）！ eos 运行示例运行下 eos_vcpkg_build\install\bin\fit-model.exe 示例程序吧 ~ 根据墨菲定律，必定没这么顺利，果然…… 一连跳几个框， 1由于找不到 opencv_core343.dll、opencv_imgcodecs343.dll、boost_filesystem-vc141-mt-x32-1_68.dll、jpeg62.dll、zlib1.dll 等，无法继续执行代码。重新安装重新可能会解决此问题。 既然缺少动态库，那就去 vcpkg 安装路径下找，如果没有则用 vcpkg 安装，然后把这些 dll 放到 fit-model.exe 同级目录下。 然后就…… 1应用程序无法正常启动(0xc000007b)。请点击“确定”关闭应用程序。 我：emmm……mmp 应该是动态库的链接错误，关于这个问题我再次开了 issue，但是作者不再回应了。 所以，在 Windows 上，只是编译成功库，但是示例都无法运行。 最终，在 Ubuntu 上，编译运行起来了。 心累。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>链接装载库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D Plugin xxx is used from several locations 错误]]></title>
    <url>%2F2019%2F01%2F07%2FUnity3DPluginXXXIsUsedFromSeveralLocations%2F</url>
    <content type="text"><![CDATA[错误12345678Plugin &apos;opencvforunity.dll&apos; is used from several locations: Assets/OpenCVForUnity/Plugins/x86/opencvforunity.dll would be copied to &lt;PluginPath&gt;/opencvforunity.dll Assets/OpenCVForUnity/Plugins/x86_64/opencvforunity.dll would be copied to &lt;PluginPath&gt;/opencvforunity.dllPlease fix plugin settings and try again.UnityEditor.Modules.DefaultPluginImporterExtension:CheckFileCollisions(String)UnityEditorInternal.PluginsHelper:CheckFileCollisions(BuildTarget) (at D:/unity/Editor/Mono/Plugins/PluginsHelper.cs:25)UnityEditor.BuildPlayerWindow:BuildPlayerAndRun() 原因我使用的 opencvforunity.dll 库的 32 位版本与 64 位版本在 Unity 编辑器中没有明确指定，所以 Unity 不知道 32 位或者 64 位系统下用哪个 opencvforunity.dll 库。 解决 为 x86 的 opencvforunity.dll 取消 x86_64 平台，只勾选 x86 平台，Apply 为 x86_64 的 opencvforunity.dll 取消 x86 平台，只勾选 x86_64 平台，Apply]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective C++ 概要]]></title>
    <url>%2F2019%2F01%2F05%2FEffectiveCppSummary%2F</url>
    <content type="text"><![CDATA[本文是 huihut . C/C++面试基础知识总结 仓库的一部分，定位链接：Effective C++ Effective C++ 视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL） 宁可以编译器替换预处理器（尽量以 const、enum、inline 替换 #define） 尽可能使用 const 确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高） 了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数） 若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现） 为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数） 别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理） 绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class） 令 operator= 返回一个 reference to *this （用于连锁赋值） 在 operator= 中处理 “自我赋值” 赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数） 以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII）） 在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr）） 在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便） 成对使用 new 和 delete 时要采取相同形式（new 中使用 [] 则 delete []，new 中不使用 [] 则 delete） 以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏） 让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任） 设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。 宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象） 必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。） 将成员变量声明为 private（为了封装、一致性、对其读写精确控制等） 宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性） 若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数 考虑写一个不抛异常的 swap 函数 尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率） 尽量少做转型动作（旧式：(T)expression、T(expression)；新式：const_cast&lt;T&gt;(expression)、dynamic_cast&lt;T&gt;(expression)、reinterpret_cast&lt;T&gt;(expression)、static_cast&lt;T&gt;(expression)、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型） 避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性） 为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型） 透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级） 将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能过够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件） 确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象） 避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日） 区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承） 考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 tr1::function 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数） 绝不重新定义继承而来的 non-virtual 函数 绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound） 通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出）） 明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承） 明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本） 了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期） 了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 basee class 修饰符） 学习处理模板化基类内的名称（可在 derived class templates 内通过 this-&gt; 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成） 将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码） 运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符） 需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”） 请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if…else 测试） 认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码） 了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常） 了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为） 编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”） 写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本） 不要轻忽编译器的警告 让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件） 让自己熟悉 Boost（准标准库）]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决七牛云链接失效以及批量下载图片并迁移阿里云 OSS]]></title>
    <url>%2F2018%2F11%2F08%2FSolveInvalidQiniuLinksAndDownloadImagesInBatchesAndMigrateAliOSS%2F</url>
    <content type="text"><![CDATA[起因七牛云对测试域名进行回收，而我博文中图片用的链接仍然是测试域名的链接，因此导致部分链接失效，浏览器返回如下错误： 1&#123;"error":"no such domain"&#125; 找回图片对象经过提交工单与七牛云工程师协商，知道了失效的图片并没有丢失，可通过某些方法找回，解决办法如下： 绑定自定义域名：如何从测试域名过渡到自定义域名（绑定后则可用自定义域名访问失效的图片） 下载单个图片：命令行辅助工具(qrsctl)（使用 qrsctl 工具的 get 下载），如下： 12.\qrsctl.exe login huihut@outlook.com 123 # 假设密码为 123.\qrsctl.exe get temp H.png ./H.png # 下载 temp 存储空间的 H.png 文件，保存到当前目录下 下载多个对象 先新建一个同区域存储空间，会分配一个新的测试域名到新空间 通过 qshell batchcopy 到有域名的同区域空间然后再进行 qdownload 下载操作：命令行工具(qshell) qshell listbucket &lt;原bucket名&gt; list.txt （list 出全部文件） https://github.com/qiniu/qshell/blob/master/docs/listbucket.md cat list.txt | awk &#39;{print $1}&#39; &gt;list_final.txt （ 用awk获取list结果的第一列） qshell batchcopy &lt;原bucket名&gt; &lt;新bucket名&gt; list_final.txt （复制到新bucket的文件和原bucket文件名一致） https://github.com/qiniu/qshell/blob/master/docs/batchcopy.md qshell qdownload newfilelist.txt （newfilelist.txt 为下载的配置文档） https://github.com/qiniu/qshell/blob/master/docs/qdownload.md 视频教程 – qshell qrsctl qfetch 命令行工具使用 准备迁移阿里云 OSS上面的解决方法中，要想继续使用七牛云存储作为图床，必须要有个实名认证的域名（解决方法一），然后绑定之 而我并没有，因此我打算把我的图片对象迁移到 阿里云 OSS 存储 上们的解决方法二、三都可以，但是二非常麻烦，三需要两个存储空间，也就需要对七牛账号进行实名认证 而我又不想另外实名认证（瞎折腾），因此我用了第二种方法：下载单个图片！[捂脸] C++ 程序下载七牛存储的对象使用 qrsctl 工具只能单个文件下载，为了避免重复的工作，我写了个 C++ 程序解决。 获取包含所有对象名的 html 文件首先进入七牛云要下载的 bucket（存储空间）的 web 界面，把内容管理列表中全部对象显示出来（点底部加载更多直到全部显示），在 Chrome 浏览器 右键 - 检查，如下图，选中 tbody - 右键 - Copy - Copy element 然后把复制到的内容保存成 html.html 文件，放到一个目录下，如我的 D:\code\test\（以下均以此目录为工程目录） 下载并登录 qrsctl下载 命令行辅助工具(qrsctl)，保存到 D:\code\test\ 目录，并重命名为 qrsctl.exe 在 D:\code\test\ 目录的 CMD 或 PowerShell 中输入如下命令登录你的七牛账号 1.\qrsctl.exe login huihut@outlook.com 123 # 假设密码为 123 编写批量下载程序在 D:\code\test\ 下创建个 QrsctlGet.cpp，把下面 C++ 代码保存到刚创建的文件，修改存储空间名为你的存储空间名的名字（本文为 temp），用 VS Code 或其他工具编译运行，七牛存储的文件即会下载到同目录下。 Github 仓库：huihut/QrsctlGet（有 QrsctlGet.Cpp、qrsctl.exe、.vscode环境） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//==============================================================// 作者：huihut// 邮箱：huihut@outlook.com// 时间：2018-11-08 14:28:00// 说明：匹配 HTML 的七牛云存储的文件名，并使用 qrsctl 下载文件//==============================================================#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#include &lt;regex&gt;using namespace std;int main()&#123; // 存储空间名【需要修改为你的存储空间名】 string bucket = "temp"; // 打开 html 文件 ifstream fhtml; fhtml.open("html.html"); // 统计下载的文件对象数 int num = 0; if (fhtml) &#123; // tbody 里面符合 reg 的奇数为文件对象，偶数是文件类型，因此只取奇数匹配项 bool isObj = true; std::stringstream buffer; buffer &lt;&lt; fhtml.rdbuf(); std::string contents(buffer.str()); std::smatch match; std::regex reg("\\b(edit-word ng-binding\"&gt;)([^&lt;]*)"); while (std::regex_search(contents, match, reg)) &#123; if (isObj) &#123; // 匹配到的文件对象 string objfile = match.format("$2"); cout &lt;&lt; "Matched " + objfile &lt;&lt; endl; // 合成下载命令 string command = "qrsctl.exe get " + bucket + " " + objfile + " ./" + objfile; // 下载文件 cout &lt;&lt; "Download " + objfile + "..." &lt;&lt; endl; system(command.c_str()); // 文件个数加一 num++; // 下一个非文件对象 isObj = false; &#125; else &#123; // 下一个是文件对象 isObj = true; &#125; contents = match.suffix().str(); &#125; &#125; else &#123; cerr &lt;&lt; "Failed to read html file!" &lt;&lt; endl; system("pause"); return -1; &#125; cout &lt;&lt; "Downloaded " + to_string(num) + " files." &lt;&lt; endl; system("pause"); return 0;&#125; 迁移阿里云 OSS在 阿里云 OSS 存储 创建阿里云账号，并在 OSS 中新建 Bucket，其中读写权限选中公共读（public-read），以便能在博文中读取 把上面下载的图片上传到阿里云 OSS，可以使用客户端上传下载：aliyun/oss-browser 然后获取外链，批量修改我的博文，把所有七牛云链接改为阿里云就好了]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>OSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 解压压缩包及 7z 库缺失导致 Can not load 7-zip library or internal COM error!]]></title>
    <url>%2F2018%2F11%2F07%2FCSharpUnzipAnd7zLibraryMissingError%2F</url>
    <content type="text"><![CDATA[表现C# 程序解压 7z 文件的时候抛出异常 1Can not load 7-zip library or internal COM error! Message: DLL file does not exist. 原因程序无法找到 7z 库，导致无法解压 7z 文件 解决方法一：使用 NuGet 包管理器下载安装选择 Visual Studio 某个项目 - 右键引用 - 管理 NuGet 程序包 - 浏览 - 搜索 7z，选择一个 7z 包，如 7z.Libs 安装即可。 方法二：手动下载安装在官网 Download 7-Zip 下载下面的 7z 库 Link Type Windows Description Download .7z x86 / x64 7-Zip Extra: standalone console version, 7z DLL, Plugin for Far Manager 解压重命名到 C:\Program Files\7-Zip 使用123456789101112131415161718192021222324252627/// &lt;summary&gt;/// 解压压缩包/// &lt;/summary&gt;/// &lt;param name="file_path"&gt;压缩包路径&lt;/param&gt;/// &lt;param name="save_path"&gt;解压后保存路径&lt;/param&gt;/// &lt;returns&gt;是否解压成功&lt;/returns&gt;private bool UncompressFile(string file_path, string save_path)&#123; try &#123; if (System.IO.Directory.Exists(save_path)) &#123; System.IO.Directory.Delete(save_path, true); &#125; // 若手动安装，需要指定路径 //SevenZip.SevenZipExtractor.SetLibraryPath(@"C:\Program Files\7-Zip\7za.dll"); SevenZip.SevenZipExtractor extractor = new SevenZip.SevenZipExtractor(file_path); extractor.ExtractArchive(save_path); extractor.Dispose(); &#125; catch (Exception e1) &#123; System.Diagnostics.Debug.WriteLine(e1.Message); return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Dotnet</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技嘉Z370 HD3P + i7-8700K + GTX1080 装黑苹果 High Sierra 10.13.6]]></title>
    <url>%2F2018%2F10%2F13%2FGIGABYTE_Z370_HD3P_i7-8700K_GTX1080_Install_Hackintosh_HighSierra10.13.6%2F</url>
    <content type="text"><![CDATA[前言本博文记录了组装台式机装黑苹果 High Sierra 10.13.6 的经历。 原本想装 Mojave 10.14 的，可惜发现在 Mojave 下还没有 GTX1080 的驱动，所以只能退而求其次装 High Sierra 了。 装 High Sierra 的过程中，第一次使用 10.13.6(17G2112) 镜像遇到个问题（下文有描述），无法进入安装界面，因此后来使用 10.13.5(17F77) 镜像装好后在 AppStore 更新 10.13.6 配置 主板：技嘉 Z370 HD3P CPU：Intel Core i7-8700K 核显：Intel UHD Graphics 630 独显：七彩虹 iGame GTX1080 Vulcan X 8G 内存：海盗船复仇者 DDR4 3200 8G*2 固态硬盘：三星 SSD 970 EVO 250GB（Windows） 机械硬盘：西数 WD10EZEX 7200PPM 64M 1T（EFI + MacOS + Storage） 板载音频：Realtek ALC1220 板载网卡：Intel I219V2 PCI Express Gigabit Ethernet USB蓝牙：绿联 CSR8891 USB蓝牙 4.0 文件本博文使用的一些软件工具驱动，下文则不赘述。 带 Clover 镜像 10.13.6(17G2112) 镜像：macOS High Sierra 10.13.6(17G2112) Installer with Clover 4606.dmg 10.13.5(17F77)镜像：macOS High Sierra 10.13.5(17F77) Installer with Clover 4512.dmg EFI 分区 huihut . Hackintosh-Z370/EFI 工具 U盘刻录工具 Etcher：官网 | 百度网盘 Clover 配置工具 Clover Configurator：官网 | 百度网盘 内核注入工具 Kext Wizard：网络 | 百度网盘 文本编辑器 BBEdit 12：官网 | 百度网盘 驱动 驱动安装工具 MultiBeast 10.4.0 - High Sierra：官网 | 百度网盘 Nvidia Web 驱动 387.10.10.10.40.105（适用于 10.13.6）：官网 | 百度网盘 Nvidia Web 驱动 387.10.10.10.35.106（适用于 10.13.5）：官网 | 百度网盘 刻录镜像准备一个8G以上的U盘，使用 Etcher 刻录上面下载的镜像（带有 Clover EFI 分区）：macOS High Sierra 10.13.6(17G2112) Installer with Clover 4606.dmg 设置 BIOS BIOS 版本已更新为 F7 Save &amp; Exit -&gt; Load Optimized Defaults : Yes M.I.T. -&gt; Advanced Memory Settings -&gt; Extreme Memory Profile(X.M.P.) : Profile 1 BIOS -&gt; Fast Boot : Disabled BIOS -&gt; CSM Support : Disabled Peripherals -&gt; Super IO Configuration -&gt; Serial Port : Disabled Peripherals -&gt; USB Configuration -&gt; XHCI Hand-off : Enabled Chipset -&gt; Vt-d : Disabled 保存 BIOS 配置 引导出错重启进入刻录好的U盘，选择 Boot macOS Install from Install macOS High Sierra 唠叨模式滚代码的时候出错：please go to https://panic.apple.com to report this panic 重新刻录上面的问题 Google 了一圈并未发现解决办法，因此重新刻录 macOS High Sierra 10.13.5(17F77) Installer with Clover 4512.dmg，先装 10.13.5(17F77) 。 引导安装这次的 10.13.5(17F77) 成功进入安装界面了。 打开磁盘工具，格好一个系统盘，格式为 APFS 或者 Mac OS 扩展（日志式），大小因人而异，我留了 128G。 格好后安装系统到这个盘。 安装过程中第一次自动重启依然进入 U 盘 Clover，引导进入格出来的盘继续安装。 第二次自动重启也是进入 U 盘 Clover，引导进入格出来的盘，然后安装完毕进入系统。 安装 CloverClover 选择进入系统后发现 1080 独显不能驱动、八代 CPU 不能识别，这个先不管，先装 Clover 到磁盘的 EFI 分区。 安装 Clover 有两种： 使用原版 CLover：Clover EFI bootloader 官方下载 使用 U 盘 EFI 分区的 Clover 由于 U 盘的 Clover 是已经试验过能引导的，所以我就用了 U 盘的。 挂载 EFI 分区在终端上执行 diskutil list，找到两个 EFI 分区（磁盘的 EFI 和 U 盘的 EFI），如下的 disk0 s1 和 disk3 s1 123456789101112131415161718192021222324252627282930313233HuiMac:~ huihut$ diskutil list/dev/disk0 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *1.0 TB disk0 1: EFI EFI 209.7 MB disk0s1 2: Apple_APFS Container disk2 128.8 GB disk0s2 3: Microsoft Basic Data Document 85.9 GB disk0s3 4: Microsoft Basic Data Software 161.1 GB disk0s4 5: Microsoft Basic Data Data 624.2 GB disk0s5/dev/disk1 (internal): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme 250.1 GB disk1 1: Microsoft Reserved 16.8 MB disk1s1 2: Microsoft Basic Data 249.2 GB disk1s2 3: Windows Recovery 847.2 MB disk1s3/dev/disk2 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +128.8 GB disk2 Physical Store disk0s2 1: APFS Volume MacOS 84.8 GB disk2s1 2: APFS Volume Preboot 67.7 MB disk2s2 3: APFS Volume Recovery 1.0 GB disk2s3 4: APFS Volume VM 20.5 KB disk2s4/dev/disk3 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *31.0 GB disk3 1: EFI EFI 209.7 MB disk3s1 2: Apple_HFS Install macOS High S... 5.7 GB disk3s2HuiMac:~ huihut$ 分别挂载到不同名字的卷 挂载磁盘 EFI12sudo mkdir /Volumes/efidisksudo mount -t msdos /dev/disk0s1 /Volumes/efidisk 挂载 U 盘 EFI12sudo mkdir /Volumes/efiusbsudo mount -t msdos /dev/disk3s1 /Volumes/efiusb 复制 Clover然后把 U 盘的 EFI/CLOVER 这个文件夹复制到 磁盘的 EFI 下 安装驱动使用 MultiBeast 安装驱动，使用 Nvidia WebDriver 安装显卡驱动（MultiBeast 的 WebDriver 不能驱动我的 1080）。 装好 Nvidia WebDriver 后 1080 能驱动，不过 i7-8700K 的八代 CPU 还是不能识别，先不管，在 AppStore 更新 10.13.6。 更新后安装驱动更新完 10.13.6 发现许多驱动有问题： 独显无法驱动 CPU无法识别 声卡无法驱动 USB3.0无法驱动 驱动独显使用适用于 10.13.6 的 WebDriver-387.10.10.10.40.105.pkg，装好重启后就 OK 了 修复 CPU 识别 参见 八代处理器安装黑苹果 关于本机显示“未知”解决办法 挂载磁盘 EFI 分区（操作如上），使用 Clover Configurator 打开 /EFI/CLOVER/config.plist 在 CPU 页面的 Type 中填入 Unknown，保存。 使用文本编辑器（如 BBEdit）打开 /System/Library/PrivateFrameworks/AppleSystemInfo.framework/Versions/A/Resources/zh_CN.lproj/AppleSystemInfo.strings 文件 修改 UnknownCPUKind 的值为 3.7 GHz Intel Core i7-8700K 保存重启即可。 修复声卡驱动 参见 黑苹果AppleALC声卡驱动安装使用教程 我使用 MultiBeast 安装的 ALC1220 驱动在 10.13.6 下不能驱动我的声卡，试过 MultiBeast 的其他驱动也不行，因此使用另一种方法修复。 在 acidanthera/AppleALC/releases 下载最新的 AppleALC 的 RELEASE 版 AppleALC.kext，使用 Kext Wizard 注入这个内核，如下图 然后挂载磁盘 EFI 分区（操作如上），把 AppleALC.kext 放入磁盘 EFI 分区的 EFI/CLOVER/kexts/Other/目录中。 然后在 acidanthera/AppleALC/Resources 找到你的声卡型号的文件夹，进入（如我的是 ALC1220）。 我的声卡型号看到有 layout1.xml、layout2.xml、layout5.xml、layout7.xml、layout11.xml、layout13.xml 然后在 1、2、5、7、11、13 中随便取一个数。 使用文本编辑器打开磁盘 EFI 分区的 EFI/CLOVER/config.plist 文件，搜索 &lt;key&gt;Audio&lt;/key&gt;，把它的 integer 改为刚刚取的那个数（如 1）。 保存重启即可。 修复 USB3.0 参见 HACKINTOSH HIGH SIERRA 10.13.6 UPDATE GUIDE 使用上文描述的操作挂载磁盘的 EFI 分区 使用 Clover Configurator 打开 /EFI/CLOVER/config.plist 如下图，插入（若已存在则修改为）配置信息 Name*: com.apple.driver.usb.AppleUSBXHCI Find* [HEX]: 837D880F 0F83A704 0000 Replace* [HEX]: 837D880F 90909090 9090 Comment: USB 10.13.6+ by PMHeart MatchOS: 10.13.x 保存重启即可。 蓝牙免驱 iMessage、序列号问题 参见 [Hackintosh]解决黑苹果无法使用Siri、iMessage等服务 更换Clover主题Clover主题可以到官方仓库下载： Clover Theme Repository 也可以使用其他的，比如我使用这个简洁风格的： Clover Minimal - A clean theme for the Clover UEFI bootloader 只需下载下来，放到 /EFI/CLOVER/themes 文件夹下，然后使用 Clover Configurator 打开 /EFI/CLOVER/config.plist 更换到这个主题就好啦。 另外这个显示启动盘的标签的 Label 建议勾上，这样才知道选择的是哪个盘，保存重启即可。 感谢 tonymacx86 黑果小兵的部落阁 黑苹果乐园 [Success] Gigabyte Z370 HD3P - i7 8700K - Gigabyte RX580 4GB - Mojave 10.14.0 Building a GTX 1080 Ti-powered Hackintosh: Installing macOS Sierra step-by-step [Video]]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyparsing 无法卸载导致安装 matplotlib 出错]]></title>
    <url>%2F2018%2F10%2F13%2FPyparsingFailsToUninstallCausingErrorInInstallingMatplotlib%2F</url>
    <content type="text"><![CDATA[表现1sudo pip install matplotlib 安装 matplotlib 时出现以下错误 12 Found existing installation: pyparsing 1.5.6Cannot uninstall &apos;pyparsing&apos;. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall. 原因安装 matplotlib 需要卸载我已安装的 1.5.6 版本的 pyparsing，再重新装新版本，但是无法卸载 解决手动重装最新版 pyparsing 首先，去官网查看最新版是什么版本：https://pypi.org/project/pyparsing/ 当前最新版是 pyparsing 2.2.0，所以执行如下重新安装最新版： 1sudo pip install -I pyparsing==2.2.0]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-dev 库缺失导致安装 matplotlib 出错]]></title>
    <url>%2F2018%2F10%2F13%2FMissingPython-devCausesErrorInInstallingMatplotlib%2F</url>
    <content type="text"><![CDATA[表现1sudo pip install matplotlib 安装 matplotlib 时出现以下错误 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Installing collected packages: subprocess32, cycler, backports.functools-lru-cache, pyparsing, kiwisolver, matplotlib Running setup.py install for subprocess32 ... error Complete output from command /usr/bin/python2 -u -c &quot;import setuptools, tokenize;__file__=&apos;/tmp/pip-install-azXKeu/subprocess32/setup.py&apos;;f=getattr(tokenize, &apos;open&apos;, open)(__file__);code=f.read().replace(&apos;\r\n&apos;, &apos;\n&apos;);f.close();exec(compile(code, __file__, &apos;exec&apos;))&quot; install --record /tmp/pip-record-5SM9_6/install-record.txt --single-version-externally-managed --compile: /usr/lib64/python2.7/distutils/dist.py:267: UserWarning: Unknown distribution option: &apos;python_requires&apos; warnings.warn(msg) running install running build running build_py creating build creating build/lib.linux-x86_64-2.7 copying subprocess32.py -&gt; build/lib.linux-x86_64-2.7 running build_ext running build_configure checking for gcc... gcc checking whether the C compiler works... yes checking for C compiler default output file name... a.out checking for suffix of executables... checking whether we are cross compiling... no checking for suffix of object files... o checking whether we are using the GNU C compiler... yes checking whether gcc accepts -g... yes checking for gcc option to accept ISO C89... none needed checking how to run the C preprocessor... gcc -E checking for grep that handles long lines and -e... /bin/grep checking for egrep... /bin/grep -E checking for ANSI C header files... yes checking for sys/types.h... yes checking for sys/stat.h... yes checking for stdlib.h... yes checking for string.h... yes checking for memory.h... yes checking for strings.h... yes checking for inttypes.h... yes checking for stdint.h... yes checking for unistd.h... yes checking for unistd.h... (cached) yes checking fcntl.h usability... yes checking fcntl.h presence... yes checking for fcntl.h... yes checking signal.h usability... yes checking signal.h presence... yes checking for signal.h... yes checking sys/cdefs.h usability... yes checking sys/cdefs.h presence... yes checking for sys/cdefs.h... yes checking for sys/types.h... (cached) yes checking for sys/stat.h... (cached) yes checking sys/syscall.h usability... yes checking sys/syscall.h presence... yes checking for sys/syscall.h... yes checking for dirent.h that defines DIR... yes checking for library containing opendir... none required checking for pipe2... yes checking for setsid... yes checking whether dirfd is declared... yes configure: creating ./config.status config.status: creating _posixsubprocess_config.h building &apos;_posixsubprocess32&apos; extension creating build/temp.linux-x86_64-2.7 gcc -pthread -fno-strict-aliasing -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -D_GNU_SOURCE -fPIC -fwrapv -DNDEBUG -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -D_GNU_SOURCE -fPIC -fwrapv -fPIC -I/usr/include/python2.7 -c _posixsubprocess.c -o build/temp.linux-x86_64-2.7/_posixsubprocess.o _posixsubprocess.c:16:20: fatal error: Python.h: No such file or directory #include &quot;Python.h&quot; ^ compilation terminated. error: command &apos;gcc&apos; failed with exit status 1 原因无法找到 python 库，#include &quot;Python.h&quot; 出错 解决 使用 apt (Ubuntu, Debian…) 安装 12sudo apt-get install python-dev # for python2.x installssudo apt-get install python3-dev # for python3.x installs 使用 yum (CentOS, RHEL…) 安装 12sudo yum install python-devel # for python2.x installssudo yum install python34-devel # for python3.4 installs 使用 dnf (Fedora…) 安装 12sudo dnf install python2-devel # for python2.x installssudo dnf install python3-devel # for python3.x installs 使用 zypper (openSUSE…) 安装 12sudo zypper in python-devel # for python2.x installssudo zypper in python3-devel # for python3.x installs 使用 apk (Alpine…) 安装 12sudo apk add python2-dev # for python2.x installssudo apk add python3-dev # for python3.x installs]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WinRT(C++/CX) UTF8类型转换为std::string和Platform::String^的Unicode字符串]]></title>
    <url>%2F2018%2F08%2F23%2FUTF8ToStdStrAndUTF8ToManagedStr%2F</url>
    <content type="text"><![CDATA[Gist 仓库地址：https://gist.github.com/huihut/8f75e2332e05673ff7e1248ad5e85339 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;string&gt;#include &lt;Windows.h&gt;std::string UTF8_To_Std_Str(const std::string &amp; str)&#123; int nwLen = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0); wchar_t* pwBuf = new wchar_t[nwLen + 1]; memset(pwBuf, 0, nwLen * 2 + 2); MultiByteToWideChar(CP_UTF8, 0, str.c_str(), str.length(), pwBuf, nwLen); int nLen = WideCharToMultiByte(CP_ACP, 0, pwBuf, -1, NULL, NULL, NULL, NULL); char* pBuf = new char[nLen + 1]; memset(pBuf, 0, nLen + 1); WideCharToMultiByte(CP_ACP, 0, pwBuf, nwLen, pBuf, nLen, NULL, NULL); std::string retStr = pBuf; delete[] pBuf; delete[] pwBuf; pBuf = NULL; pwBuf = NULL; return retStr;&#125;Platform::String^ UTF8_To_Managed_Str(const std::string &amp; str)&#123; int nwLen = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0); wchar_t* pwBuf = new wchar_t[nwLen + 1]; memset(pwBuf, 0, nwLen * 2 + 2); MultiByteToWideChar(CP_UTF8, 0, str.c_str(), str.length(), pwBuf, nwLen); Platform::String^ pStr = ref new Platform::String(pwBuf); delete[] pwBuf; pwBuf = NULL; return pStr;&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WinRT(C++/CX) Platform::String^ 与 std::string 的类型转换]]></title>
    <url>%2F2018%2F08%2F23%2FTypeConversionBetweenPlatformStringAndStdstring%2F</url>
    <content type="text"><![CDATA[Gist 仓库地址：https://gist.github.com/huihut/aa90bd3a202090e25b9a4792c80e6920 1234567891011121314#include &lt;string&gt;std::string Managed_Str_To_Std_Str(Platform::String^ ms)&#123; std::wstring w_str(ms-&gt;Begin()); return std::string(w_str.begin(), w_str.end());&#125;Platform::String^ Std_Str_To_Managed_Str(const std::string &amp; input)&#123; std::wstring w_str = std::wstring(input.begin(), input.end()); const wchar_t* w_chars = w_str.c_str(); return (ref new Platform::String(w_chars));&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV使用CMake和MinGW-w64的编译安装]]></title>
    <url>%2F2018%2F07%2F31%2FCompiledOpenCVWithMinGW64%2F</url>
    <content type="text"><![CDATA[前言之前写过的一篇博文：OpenCV使用CMake和MinGW的编译安装及其在Qt配置运行 是使用 32 位的 MinGW 在 Windows 下编译 OpenCV 生成 32 位的 dll。 而这篇博文是使用 64 位的 MinGW 编译 OpenCV 生成 64 位的 dll。 因为博主没有 64 位 qmake，所以没勾选 WITH_QT 编译好的 OpenCV（MinGW 版）：Github . huihut/OpenCV-MinGW-Build 软件环境 Windows-10-64bit MinGW-x64-4.8.1-release-posix-seh-rev5 CMake-3.12.0 OpenCV-3.4.1 | OpenCV-4.0.0-alpha | OpenCV-4.0.0-rc | OpenCV-4.1.0 安装 MinGW-w64 并配置环境变量下载安装：MinGW-x64-4.8.1-release-posix-seh-rev5 （博文使用 MinGW-x64-4.8.1 为例，但建议使用最新 MinGW：MinGW-w64 - for 32 and 64 bit Windows） 为用户变量 Path 添加 E:\MinGW-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\bin 使环境变量生效打开命令提示符 CMD，运行 set PATH=C:，更改当前窗口任务的环境变量，关闭这个 CMD。 再次打开另一个 CMD，运行 echo %PATH%，显示最新的环境变量，会发现刚刚添加的 MinGW 环境变量已经生效。 使用 CMake 生成 OpenCV 的 Makefile打开 cmake-gui，设置源码和生成路径： Where is the source code: E:/opencv_341/opencv/sources Where to build the binaries: E:/opencv_341/opencv_mingw64_build 点击 Configure，设置编译器 Specify the generator for this project: MinGW Makefiles Specify native compilers Next Compilers C: E:\MinGW-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\bin\gcc.exe Compilers C++: E:\MinGW-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\bin\g++.exe Finish 编译配置： 勾选 WITH_OPENGL 勾选 ENABLE_CXX11 不勾选 WITH_IPP 不勾选 ENABLE_PRECOMPILED_HEADERS 点击 Configure，Generate 生成 Makefile 博主的配置信息如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106General configuration for OpenCV 3.4.1 ===================================== Version control: unknown Platform: Timestamp: 2018-07-31T02:14:11Z Host: Windows 10.0.17134 AMD64 CMake: 3.12.0 CMake generator: MinGW Makefiles CMake build tool: E:/MinGW-w64/x64-4.8.1-release-posix-seh-rev5/mingw64/bin/mingw32-make.exe Configuration: Release CPU/HW features: Baseline: SSE SSE2 SSE3 requested: SSE3 Dispatched code generation: SSE4_1 SSE4_2 FP16 AVX AVX2 requested: SSE4_1 SSE4_2 AVX FP16 AVX2 AVX512_SKX SSE4_1 (3 files): + SSSE3 SSE4_1 SSE4_2 (1 files): + SSSE3 SSE4_1 POPCNT SSE4_2 FP16 (2 files): + SSSE3 SSE4_1 POPCNT SSE4_2 FP16 AVX AVX (5 files): + SSSE3 SSE4_1 POPCNT SSE4_2 AVX AVX2 (9 files): + SSSE3 SSE4_1 POPCNT SSE4_2 FP16 FMA3 AVX AVX2 C/C++: Built as dynamic libs?: YES C++11: YES C++ Compiler: E:/MinGW-w64/x64-4.8.1-release-posix-seh-rev5/mingw64/bin/g++.exe (ver 4.8.1) C++ flags (Release): -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wuninitialized -Winit-self -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-comment -fdiagnostics-show-option -Wno-long-long -fomit-frame-pointer -ffunction-sections -fdata-sections -msse -msse2 -msse3 -fvisibility=hidden -fvisibility-inlines-hidden -O3 -DNDEBUG -DNDEBUG C++ flags (Debug): -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wuninitialized -Winit-self -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-comment -fdiagnostics-show-option -Wno-long-long -fomit-frame-pointer -ffunction-sections -fdata-sections -msse -msse2 -msse3 -fvisibility=hidden -fvisibility-inlines-hidden -g -O0 -DDEBUG -D_DEBUG C Compiler: E:/MinGW-w64/x64-4.8.1-release-posix-seh-rev5/mingw64/bin/gcc.exe C flags (Release): -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wuninitialized -Winit-self -Wno-narrowing -Wno-comment -fdiagnostics-show-option -Wno-long-long -fomit-frame-pointer -ffunction-sections -fdata-sections -msse -msse2 -msse3 -fvisibility=hidden -O3 -DNDEBUG -DNDEBUG C flags (Debug): -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wuninitialized -Winit-self -Wno-narrowing -Wno-comment -fdiagnostics-show-option -Wno-long-long -fomit-frame-pointer -ffunction-sections -fdata-sections -msse -msse2 -msse3 -fvisibility=hidden -g -O0 -DDEBUG -D_DEBUG Linker flags (Release): -Wl,--gc-sections Linker flags (Debug): -Wl,--gc-sections ccache: NO Precompiled headers: NO Extra dependencies: opengl32 glu32 3rdparty dependencies: OpenCV modules: To be built: calib3d core dnn features2d flann highgui imgcodecs imgproc java_bindings_generator ml objdetect photo python_bindings_generator shape stitching superres ts video videoio videostab Disabled: js world Disabled by dependency: - Unavailable: cudaarithm cudabgsegm cudacodec cudafeatures2d cudafilters cudaimgproc cudalegacy cudaobjdetect cudaoptflow cudastereo cudawarping cudev java python2 python3 viz Applications: tests perf_tests apps Documentation: NO Non-free algorithms: NO Windows RT support: NO GUI: Win32 UI: YES OpenGL support: YES (opengl32 glu32) VTK support: NO Media I/O: ZLib: build (ver 1.2.11) JPEG: build (ver 90) WEBP: build (ver encoder: 0x020e) PNG: build (ver 1.6.34) TIFF: build (ver 42 - 4.0.9) JPEG 2000: build (ver 1.900.1) OpenEXR: build (ver 1.7.1) Video I/O: Video for Windows: YES DC1394: NO FFMPEG: YES (prebuilt binaries) avcodec: YES (ver 57.107.100) avformat: YES (ver 57.83.100) avutil: YES (ver 55.78.100) swscale: YES (ver 4.8.100) avresample: YES (ver 3.7.0) GStreamer: NO DirectShow: YES Parallel framework: none Trace: YES (built-in) Other third-party libraries: Lapack: NO Eigen: NO Custom HAL: NO Protobuf: build (3.5.1) NVIDIA CUDA: NO OpenCL: YES (no extra features) Include path: E:/opencv_341/opencv/sources/3rdparty/include/opencl/1.2 Link libraries: Dynamic load Python (for build): E:/Python37-32/python.exe Java: ant: NO JNI: C:/Program Files (x86)/Java/jdk1.8.0_181/include C:/Program Files (x86)/Java/jdk1.8.0_181/include/win32 C:/Program Files (x86)/Java/jdk1.8.0_181/include Java wrappers: NO Java tests: NO Matlab: NO Install to: E:/opencv_341/opencv_mingw64_build/install-----------------------------------------------------------------Configuring doneGenerating done 编译 OpenCV打开终端进行编译：（-j 是使用 8 个线程进行编译，请根据你的计算机配置合理设置线程数） 1234E:cd E:\opencv_341\opencv_mingw64_buildmingw32-make -j 8mingw32-make install 如果 mingw32-make -j 8 遇到错误，请看下面的 编译 OpenCV 常见错误，否则执行 mingw32-make install，完成安装。 编译 OpenCV 常见错误1. MinGW-w64 的 aviriff.h 文件注释错误表现12345678910111213141516171819[ 49%] Building CXX object modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_dshow.cpp.objIn file included from E:\opencv_341\opencv\sources\modules\videoio\src\cap_dshow.cpp:113:0:e:\mingw-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\x86_64-w64-mingw32\include\aviriff.h:2:8: error: expected constructor, destructor, or type conversion before &apos;file&apos; * This file is part of the mingw-w64 runtime package. ^e:\mingw-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\x86_64-w64-mingw32\include\aviriff.h:3:25: error: &apos;refer&apos; does not name a type * No warranty is given; refer to the file DISCLAIMER within this package. ^In file included from e:\mingw-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\x86_64-w64-mingw32\include\aviriff.h:19:0, from E:\opencv_341\opencv\sources\modules\videoio\src\cap_dshow.cpp:113:e:\mingw-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\x86_64-w64-mingw32\include\pshpack2.h:7:21: error: expected declaration before end of line #pragma pack(push,2) ^modules\videoio\CMakeFiles\opencv_videoio.dir\build.make:146: recipe for target &apos;modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_dshow.cpp.obj&apos; failedmingw32-make[2]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_dshow.cpp.obj] Error 1CMakeFiles\Makefile2:3057: recipe for target &apos;modules/videoio/CMakeFiles/opencv_videoio.dir/all&apos; failedmingw32-make[1]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/all] Error 2Makefile:161: recipe for target &apos;all&apos; failedmingw32-make: *** [all] Error 2 解决打开E:\MinGW-w64\x64-4.8.1-release-posix-seh-rev5\mingw64\x86_64-w64-mingw32\include\aviriff.h 发现第一行的多行注释少了个/符号，加上保存，如下： 1234/*** This file is part of the mingw-w64 runtime package.* No warranty is given; refer to the file DISCLAIMER within this package.*/ 然后重新 Configure-Generate-mingw32-make 就好了。 2. cap_msmf.cpp capture code 错误【2018年10月13日修改，因编译 OpenCV-4.0.0-alpha 时遇到并解决】表现12345678910111213141516171819202122232425262728293031......E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp: In member function &apos;HRESULT &#123;anonymous&#125;::ComPtr&lt;T&gt;::As(&#123;anonymous&#125;::ComPtr&lt;U&gt;&amp;) const [with U = IMF2DBuffer; T = IMFMediaBuffer; HRESULT = long int]&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp:172:5: error: control reaches end of non-void function [-Werror=return-type] &#125; ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp: In member function &apos;T* &#123;anonymous&#125;::ComPtr&lt;T&gt;::operator-&gt;() const [with T = IMF2DBuffer]&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp:149:5: error: control reaches end of non-void function [-Werror=return-type] &#125; ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp: In member function &apos;T* &#123;anonymous&#125;::ComPtr&lt;T&gt;::operator-&gt;() const [with T = IMFMediaBuffer]&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp:149:5: error: control reaches end of non-void function [-Werror=return-type] &#125; ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp: In member function &apos;T* &#123;anonymous&#125;::ComPtr&lt;T&gt;::operator-&gt;() const [with T = IMFSinkWriter]&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp:149:5: error: control reaches end of non-void function [-Werror=return-type] &#125; ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp: In member function &apos;T* &#123;anonymous&#125;::ComPtr&lt;T&gt;::Get() const [with T = IMFMediaBuffer]&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\videoio\src\cap_msmf.cpp:158:5: error: control reaches end of non-void function [-Werror=return-type] &#125; ^cc1plus.exe: some warnings being treated as errorsmodules\videoio\CMakeFiles\opencv_videoio.dir\build.make:188: recipe for target &apos;modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_msmf.cpp.obj&apos; failedmingw32-make[2]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_msmf.cpp.obj] Error 1CMakeFiles\Makefile2:2556: recipe for target &apos;modules/videoio/CMakeFiles/opencv_videoio.dir/all&apos; failedmingw32-make[1]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/all] Error 2mingw32-make[1]: *** Waiting for unfinished jobs....[ 58%] Linking CXX shared library ..\..\bin\libopencv_dnn400.dll[ 59%] Built target opencv_dnnMakefile:161: recipe for target &apos;all&apos; failedmingw32-make: *** [all] Error 2 原因因为 MinGW 不能编译 OpenCV 的 cap_msmf 那部分代码，具体见我提的 Issue：Failed to compile opencv-4.0.0-alpha using mingw-w64。 解决所以，在 cmake-gui 编译配置中： 不勾选 WITH_MSMF 然后重新 Configure-Generate-mingw32-make 3. ‘M_PI’ was not declared in this scope 错误【2018年10月13日修改，因编译 OpenCV-4.0.0-alpha 时遇到并解决】表现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768[ 86%] Building CXX object modules/calib3d/CMakeFiles/opencv_calib3d.dir/src/chessboard.cpp.objIn file included from E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:7:0:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.hpp: In constructor &apos;cv::details::FastX::Parameters::Parameters()&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.hpp:35:36: error: &apos;M_PI&apos; was not declared in this scope resolution = float(M_PI*0.25); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: At global scope:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:25:42: error: &apos;M_PI&apos; was not declared in this scope const float MAX_ANGLE = float(48.0/180.0*M_PI); // max angle between line segments supposed to be straight ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:26:48: error: &apos;M_PI&apos; was not declared in this scope const float MIN_COS_ANGLE = float(cos(35.0/180*M_PI)); // min cos angle between board edges ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:29:35: error: &apos;M_PI&apos; was not declared in this scope const float RAD2DEG = float(180.0/M_PI); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In function &apos;int cv::details::testPointSymmetry(cv::Mat, cv::Point2f, float, float)&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:217:33: error: &apos;M_PI&apos; was not declared in this scope for(double angle=0;angle &lt;= M_PI;angle+=M_PI*0.1) ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In member function &apos;void cv::details::FastX::rotate(float, const cv::Mat&amp;, cv::Size, cv::Mat&amp;) const&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:287:110: error: &apos;M_PI&apos; was not declared in this scope cv::Mat m = cv::getRotationMatrix2D(cv::Point2f(float(img.cols*0.5),float(img.rows*0.5)),float(angle/M_PI*180),1); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In member function &apos;std::vector&lt;std::vector&lt;float&gt; &gt; cv::details::FastX::calcAngles(const std::vector&lt;cv::Mat&gt;&amp;, std::vector&lt;cv::KeyPoint&gt;&amp;) const&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:393:30: error: &apos;M_PI&apos; was not declared in this scope float resolution = float(M_PI/channels); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In member function &apos;void cv::details::FastX::detectImpl(const cv::Mat&amp;, std::vector&lt;cv::Mat&gt;&amp;, std::vector&lt;cv::Mat&gt;&amp;, const cv::Mat&amp;) const&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:631:30: error: &apos;M_PI&apos; was not declared in this scope int num = int(0.5001*M_PI/parameters.resolution); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In member function &apos;void cv::details::Ellipse::draw(cv::InputOutputArray, const Scalar&amp;) const&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:721:43: error: &apos;M_PI&apos; was not declared in this scope cv::ellipse(img,center,axes,360-angle/M_PI*180,0,360,color); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In static member function &apos;static float cv::details::Chessboard::Board::findMaxPoint(cv::flann::Index&amp;, const cv::Mat&amp;, const cv::details::Ellipse&amp;, float, float, cv::Point2f&amp;)&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:1541:17: error: &apos;M_PI&apos; was not declared in this scope if(a1 &gt; M_PI*0.5) ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:1543:16: error: &apos;M_PI&apos; was not declared in this scope if(a2&gt; M_PI*0.5) ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In static member function &apos;static bool cv::details::Chessboard::Board::estimateSearchArea(const Point2f&amp;, const Point2f&amp;, const Point2f&amp;, float, cv::details::Ellipse&amp;, const Point2f*)&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:1787:28: error: &apos;M_PI&apos; was not declared in this scope angle = float(2.0F*M_PI-angle); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In member function &apos;void cv::details::Chessboard::findKeyPoints(const cv::Mat&amp;, std::vector&lt;cv::KeyPoint&gt;&amp;, std::vector&lt;cv::Mat&gt;&amp;, std::vector&lt;std::vector&lt;float&gt; &gt;&amp;, const cv::Mat&amp;) const&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:2793:29: error: &apos;M_PI&apos; was not declared in this scope para.resolution = float(M_PI*0.25); // this gives the best results taking interpolation into account ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In member function &apos;cv::Mat cv::details::Chessboard::buildData(const std::vector&lt;cv::KeyPoint&gt;&amp;) const&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:2844:30: error: &apos;M_PI&apos; was not declared in this scope (*val++) = float(2.0*M_PI-iter-&gt;angle/180.0*M_PI); ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp: In member function &apos;std::vector&lt;cv::KeyPoint&gt; cv::details::Chessboard::getInitialPoints(cv::flann::Index&amp;, const cv::Mat&amp;, const cv::KeyPoint&amp;, float, float, float) const&apos;:E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:2874:25: error: &apos;M_PI&apos; was not declared in this scope if(angle_temp &gt; M_PI*0.5) ^E:\opencv-4.0.0-alpha\opencv-4.0.0-alpha\modules\calib3d\src\chessboard.cpp:2879:29: error: &apos;M_PI&apos; was not declared in this scope if(angle_temp &gt; M_PI*0.5) ^modules\calib3d\CMakeFiles\opencv_calib3d.dir\build.make:137: recipe for target &apos;modules/calib3d/CMakeFiles/opencv_calib3d.dir/src/chessboard.cpp.obj&apos; failedmingw32-make[2]: *** [modules/calib3d/CMakeFiles/opencv_calib3d.dir/src/chessboard.cpp.obj] Error 1CMakeFiles\Makefile2:3018: recipe for target &apos;modules/calib3d/CMakeFiles/opencv_calib3d.dir/all&apos; failedmingw32-make[1]: *** [modules/calib3d/CMakeFiles/opencv_calib3d.dir/all] Error 2Makefile:161: recipe for target &apos;all&apos; failedmingw32-make: *** [all] Error 2 原因因为 OpenCV 在 chessboard.cpp、chessboard.hpp、test_chesscorners.cpp 这些代码中有 BUG，使用的应该是 CV_PI 而不是 M_PI 导致的。具体见我提的 Issue：Failed to compile opencv-4.0.0-alpha using mingw-w64 解决 在最新的 master 分支已经解决了这个问题，见我的 PR ：M_PI changed to CV_PI 如果你是在 官网 或者 github.com/opencv/opencv/releases 中下的 OpenCV 4.0.0-alpha，可能还会有这个问题，那么你需要把 chessboard.cpp、chessboard.hpp、test_chesscorners.cpp 文件中的 M_PI 全部改为 CV_PI，如我的 commit 所示：M_PI changed to CV_PI (#12645) 然后重新 Configure-Generate-mingw32-make 4. ‘posix_memalign’ was not declared in this scope 错误【2018年11月17日修改，因编译 OpenCV-4.0.0-rc 时遇到并解决】表现12345678[ 28%] Building CXX object modules/CMakeFiles/ade.dir/__/3rdparty/ade/ade-0.1.1c/sources/ade/source/alloc.cpp.objE:\opencv-4.0.0-rc\opencv-4.0.0-rc-build\3rdparty\ade\ade-0.1.1c\sources\ade\source\alloc.cpp: In function &apos;void* ade::aligned_alloc(std::size_t, std::size_t)&apos;:E:\opencv-4.0.0-rc\opencv-4.0.0-rc-build\3rdparty\ade\ade-0.1.1c\sources\ade\source\alloc.cpp:31:16: error: &apos;posix_memalign&apos; was not declared in this scope auto res = posix_memalign(&amp;ret, std::max(sizeof(void*), alignment), size); ^~~~~~~~~~~~~~mingw32-make[2]: *** [modules\CMakeFiles\ade.dir\build.make:63: modules/CMakeFiles/ade.dir/__/3rdparty/ade/ade-0.1.1c/sources/ade/source/alloc.cpp.obj] Error 1mingw32-make[1]: *** [CMakeFiles\Makefile2:884: modules/CMakeFiles/ade.dir/all] Error 2mingw32-make: *** [Makefile:162: all] Error 2 原因因为我使用了 MinGW-w64-8.1.0 编译，而新的编译器在 Windows 下不再定义 WIN32，而定义成 _WIN32，如这个 Issue 的问题：error: ‘posix_memalign’ was not declared in this scope #12831 解决把 opencv-4.0.0-rc-build\3rdparty\ade\ade-0.1.1c\sources\ade\source\alloc.cpp 文件的所有 WIN32 改为 _WIN32，如这个 PR 所做的修改：fix check for win32 #6 然后重新 Configure-Generate-mingw32-make 5. ‘D3D11_TEXTURE2D_DESC’ was not declared in this scope 错误【2019年4月10日修改，因编译 OpenCV-4.1.0 时遇到并解决】表现12345[ 32%] Building CXX object modules/core/CMakeFiles/opencv_core.dir/src/directx.cpp.objE:\opencv-4.1.0\opencv-4.1.0\modules\core\src\directx.cpp: In function &apos;void cv::directx::__convertToD3D11Texture2DNV(cv::InputAray, ID3D11Texture2D*)&apos;:E:\opencv-4.1.0\opencv-4.1.0\modules\core\src\directx.cpp:1035:5: error: &apos;D3D11_TEXTURE2D_DESC&apos; was not declared in this scope D3D11_TEXTURE2D_DESC desc = &#123; 0 &#125;; ^~~~~~~~~~~~~~~~~~~~ 原因D3D11_TEXTURE2D_DESC 在 d3d11.h 中定义，貌似在我的机器上找不到定义。反正也不用 D3D11 与 OpenCL 交互，因此可以关闭 WITH_OPENCL_D3D11_NV 这个选项（默认是开的）。可见我的 issue：Error compiling 4.1.0 source code with mingw-w64: ‘D3D11_TEXTURE2D_DESC’ was not declared in this scope #14286 解决方法一： 在 cmake-gui 编译配置中： 不勾选 WITH_OPENCL_D3D11_NV 然后重新 Configure-Generate-mingw32-make 方法二： 如这个 PR 中对这两个 cmake 文件的修改：cmake: fix WITH_OPENCL_D3D11_NV check #14294，即可先判断是否可以用，再设置默认的 WITH_OPENCL_D3D11_NV 其他错误如果以上错误不是你所遇到的，请务必先看下面两个文章中的错误。 编译 32位 OpenCV 博文的常见错误 Tutorial: Installation from source for Windows with Mingw-w64 更新日志 2018年10月13日为 OpenCV-4.0.0-alpha 而修改，主要改了 “编译 OpenCV 常见错误” 2018年11月17日为 OpenCV-4.0.0-rc 而修改，主要改了 “编译 OpenCV 常见错误” 2019年4月10日为 OpenCV-4.1.0 而修改，主要改了 “编译 OpenCV 常见错误”]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>链接装载库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 下 CLion 编写调用 C++ 共享库]]></title>
    <url>%2F2018%2F07%2F20%2FWritingCppSharedLibraryOnLinuxCLion%2F</url>
    <content type="text"><![CDATA[编写 MySharedLib 共享库创建一个名为 MySharedLib 的共享库 CMakeLists.txt123456cmake_minimum_required(VERSION 3.10)project(MySharedLib)set(CMAKE_CXX_STANDARD 11)add_library(MySharedLib SHARED library.cpp library.h) library.h12345678910111213141516171819#ifndef MYSHAREDLIB_LIBRARY_H#define MYSHAREDLIB_LIBRARY_H// 打印 Hello World!void hello();// 使用可变模版参数求和template &lt;typename T&gt;T sum(T t)&#123;return t;&#125;template &lt;typename T, typename ...Types&gt;T sum(T first, Types ... rest)&#123;return first + sum&lt;T&gt;(rest...);&#125;#endif library.cpp123456#include &lt;iostream&gt;#include "library.h"void hello() &#123;std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;&#125; 被 TestSharedLib 可执行项目调用创建一个名为 TestSharedLib 的可执行项目 CMakeLists.txt12345678910111213141516171819cmake_minimum_required(VERSION 3.10)project(TestSharedLib)# C++11 编译set(CMAKE_CXX_STANDARD 11)# 头文件路径set(INC_DIR /home/xx/code/clion/MySharedLib)# 库文件路径set(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)include_directories($&#123;INC_DIR&#125;)link_directories($&#123;LIB_DIR&#125;)link_libraries(MySharedLib)add_executable(TestSharedLib main.cpp)# 链接 MySharedLib 库target_link_libraries(TestSharedLib MySharedLib) main.cpp12345678910111213#include &lt;iostream&gt;#include "library.h"using std::cout;using std::endl;int main() &#123;hello();cout &lt;&lt; "1 + 2 = " &lt;&lt; sum(1,2) &lt;&lt; endl;cout &lt;&lt; "1 + 2 + 3 = " &lt;&lt; sum(1,2,3) &lt;&lt; endl;return 0;&#125; 执行结果123Hello, World!1 + 2 = 31 + 2 + 3 = 6]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UWP 动画改变控件大小（高度）]]></title>
    <url>%2F2018%2F07%2F18%2FUWPAnimationChangesControlHeight%2F</url>
    <content type="text"><![CDATA[有这样一个需求： 鼠标移动到（悬停在）控件上（PointerEntered），控件大小（高度）发生变化，以显示更多内容； 鼠标移出控件（PointerExited），控件大小恢复原状。 本文通过 UWP 动画，用两种方法实现这个效果，用于改变周贡献榜和粉丝榜的 Grid 的高度。 方法一：XAML 实现动画XAML：1234567891011121314&lt;UserControl.Resources&gt; &lt;!--周贡、粉丝榜下拉恢复动画--&gt; &lt;Storyboard x:Name="SeeMoreAnimation" Storyboard.TargetName="WeekFansGrid"&gt; &lt;DoubleAnimation Duration="0:0:0.2" EnableDependentAnimation="True" Storyboard.TargetProperty="Height" From="140" To="400"/&gt; &lt;/Storyboard&gt; &lt;Storyboard x:Name="RestoreAnimation" Storyboard.TargetName="WeekFansGrid"&gt; &lt;DoubleAnimation Duration="0:0:0.2" EnableDependentAnimation="True" Storyboard.TargetProperty="Height" From="400" To="140"/&gt; &lt;/Storyboard&gt;&lt;/UserControl.Resources&gt;&lt;Grid x:Name="WeekFansGrid" Background="White" VerticalAlignment="Top" Height="140" PointerEntered="Grid_PointerEntered" PointerExited="Grid_PointerExited"&gt; &lt;!--Grid 里面的一些内容--&gt;&lt;/Grid&gt; C#：12345678910111213141516171819202122232425// 鼠标悬停周贡、粉丝榜的 Gridprivate void Grid_PointerEntered(object sender, PointerRoutedEventArgs e)&#123; try &#123; SeeMoreAnimation.Begin(); &#125; catch (Exception e1) &#123; System.Diagnostics.Debug.WriteLine("Grid_PointerEntered " + e1.Message.ToString()); &#125;&#125;// 鼠标离开周贡、粉丝榜的 Gridprivate void Grid_PointerExited(object sender, PointerRoutedEventArgs e)&#123; try &#123; RestoreAnimation.Begin(); &#125; catch (Exception e1) &#123; System.Diagnostics.Debug.WriteLine("Grid_PointerExited " + e1.Message.ToString()); &#125;&#125; 方法二：后台实现动画XAML：1234&lt;Grid x:Name="WeekFansGrid" Background="White" VerticalAlignment="Top" Height="140" PointerEntered="Grid_PointerEntered" PointerExited="Grid_PointerExited"&gt; &lt;!--Grid 里面的一些内容--&gt; &lt;/Grid&gt; C#：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 鼠标悬停周贡、粉丝榜的 Gridprivate void Grid_PointerEntered(object sender, PointerRoutedEventArgs e)&#123; try &#123; Grid grid = sender as Grid; if (grid != null) &#123; DoubleAnimation SeeMoreAnimation = new DoubleAnimation(); if (SeeMoreAnimation != null) &#123; // 高度从 140 变化到 400 SeeMoreAnimation.From = 140; SeeMoreAnimation.To = 400; // 用时 200 毫秒 SeeMoreAnimation.Duration = new Duration(TimeSpan.FromMilliseconds(200)); SeeMoreAnimation.EnableDependentAnimation = true; // 目标 Grid 的 Height Storyboard.SetTarget(SeeMoreAnimation, grid); Storyboard.SetTargetProperty(SeeMoreAnimation, "Height"); Storyboard storyboard = new Storyboard(); if (storyboard != null) &#123; storyboard.Children.Add(SeeMoreAnimation); // 执行动画 storyboard.Begin(); &#125; &#125; &#125; &#125; catch (Exception e1) &#123; System.Diagnostics.Debug.WriteLine("Grid_PointerEntered " + e1.Message.ToString()); &#125;&#125;// 鼠标离开周贡、粉丝榜的 Gridprivate void Grid_PointerExited(object sender, PointerRoutedEventArgs e)&#123; try &#123; Grid grid = sender as Grid; if (grid != null) &#123; DoubleAnimation SeeMoreAnimation = new DoubleAnimation(); if (SeeMoreAnimation != null) &#123; // 高度从 400 变化到 140 SeeMoreAnimation.From = 400; SeeMoreAnimation.To = 140; // 用时 200 毫秒 SeeMoreAnimation.Duration = new Duration(TimeSpan.FromMilliseconds(200)); SeeMoreAnimation.EnableDependentAnimation = true; // 目标 Grid 的 Height Storyboard.SetTarget(SeeMoreAnimation, grid); Storyboard.SetTargetProperty(SeeMoreAnimation, "Height"); Storyboard storyboard = new Storyboard(); if (storyboard != null) &#123; storyboard.Children.Add(SeeMoreAnimation); // 执行动画 storyboard.Begin(); &#125; &#125; &#125; &#125; catch (Exception e1) &#123; System.Diagnostics.Debug.WriteLine("Grid_PointerExited " + e1.Message.ToString()); &#125;&#125; 实现效果]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Dotnet</tag>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 生成带标签数据集的 CSV 文件]]></title>
    <url>%2F2018%2F06%2F17%2FUsingPythonToCreateCSV%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#!/usr/bin/python# -*- coding: UTF-8 -*-# Python 生成 CSV 文件# Python 生成 CSV 文件，可用于生成带标签的数据集 CSV 文件，标签从0开始自动升序：0,1,2,3...# 作者：huihut# 仓库：https://gist.github.com/huihut/9881c98a1d9279d4fa9dfd8475e3fe4b# 参考：https://github.com/opencv/opencv_attic/blob/master/opencv/modules/contrib/doc/facerec/src/create_csv.py'''使用脚本：* python create_csv.py &lt;base_path&gt; [save_path]例如：* python create_csv.py /Users/xx/code/dataset* python create_csv.py /Users/xx/code/dataset ./dataset_csv.txt目录结构（使用 tree 命令查看）：xx@xxs-MacBook-Pro:~/code/dataset$ tree.├── README├── dataset_csv.txt├── s01│ ├── 01.pgm│ ├── ...│ └── 10.pgm├── s02│ ├── 01.pgm│ ├── ...│ └── 10.pgm...└── s10 ├── 01.pgm ├── ... └── 10.pgm生成的 CSV 文件内容（使用 cat 命令查看 dataset_csv.txt 文件内容）：xx@xxs-MacBook-Pro:~/code/dataset$ cat dataset_csv.txt/Users/xx/code/dataset/s01/01.pgm;0/Users/xx/code/dataset/s01/02.pgm;0.../Users/xx/code/dataset/s01/10.pgm;0/Users/xx/code/dataset/s02/01.pgm;1/Users/xx/code/dataset/s02/02.pgm;1.../Users/xx/code/dataset/s10/01.pgm;9/Users/xx/code/dataset/s10/02.pgm;9.../Users/xx/code/dataset/s10/10.pgm;9'''import sysimport os.pathif __name__ == "__main__": SAVE_PATH = "./dataset_csv.txt" if (len(sys.argv) != 2 and len(sys.argv) != 3): print "usage:" print "* python create_csv.py &lt;base_path&gt; [save_path]" print "example:" print "* python create_csv.py /Users/xx/code/dataset" print "* python create_csv.py /Users/xx/code/dataset ./dataset_csv.txt" sys.exit(1) elif (len(sys.argv) == 3): SAVE_PATH = sys.argv[2] BASE_PATH = sys.argv[1] SEPARATOR = ";" fh = open(SAVE_PATH,'w') label = 0 for dirname, dirnames, filenames in os.walk(BASE_PATH): for subdirname in dirnames: subject_path = os.path.join(dirname, subdirname) for filename in os.listdir(subject_path): abs_path = "%s/%s" % (subject_path, filename) print "%s%s%d" % (abs_path, SEPARATOR, label) fh.write(abs_path + SEPARATOR + str(label) + "\n") label = label + 1 fh.close()]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode 的 C/C++ 调试环境的 launch.json、 tasks.json 文件]]></title>
    <url>%2F2018%2F06%2F12%2FVSCodeCppLaunchTasks%2F</url>
    <content type="text"><![CDATA[launch.json12345678910111213141516171819202122232425262728293031323334353637// Configuring tasks.json for C/C++ debugging// author: huihut// repo: https://gist.github.com/huihut/9548fe7e1084cf8e844120c5668b8177// Available variables which can be used inside of strings.// $&#123;workspaceRoot&#125;: the root folder of the team // $&#123;file&#125;: the current opened file // $&#123;fileBasename&#125;: the current opened file's basename // $&#123;fileDirname&#125;: the current opened file's dirname // $&#123;fileExtname&#125;: the current opened file's extension // $&#123;cwd&#125;: the current working directory of the spawned process&#123; "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", "preLaunchTask": "build", "type": "cppdbg", "request": "launch", "program": "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe", "args": [], "stopAtEntry": false, "cwd": "$&#123;workspaceFolder&#125;", "environment": [], "externalConsole": true, "MIMode": "gdb", "miDebuggerPath": "gdb.exe", "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ] &#125;]&#125; tasks.json123456789101112131415161718192021222324252627282930313233343536373839404142// Configuring tasks.json for C/C++ debugging // author: huihut// repo: https://gist.github.com/huihut/887d3c28db92617bd5148c20a5ff112a// Available variables which can be used inside of strings.// $&#123;workspaceRoot&#125;: the root folder of the team // $&#123;file&#125;: the current opened file // $&#123;fileBasename&#125;: the current opened file's basename // $&#123;fileDirname&#125;: the current opened file's dirname // $&#123;fileExtname&#125;: the current opened file's extension // $&#123;cwd&#125;: the current working directory of the spawned process&#123; "version": "2.0.0", "tasks": [ &#123; "label": "build", "type": "shell", "group": &#123; "kind": "build", "isDefault": true &#125;, "presentation": &#123; "echo": true, "reveal": "always", "focus": false, "panel": "shared" &#125;, "windows": &#123; "command": "g++", "args": [ "-ggdb", "\"$&#123;file&#125;\"", "--std=c++11", "-o", "\"$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe\"" ] &#125; &#125; ]&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 调用 Python 模块]]></title>
    <url>%2F2018%2F06%2F12%2FCppCallPython%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546// C++ call Python module // author: huihut// repo: https://gist.github.com/huihut/b4597d097123a8c8388c71b3f0ff21e5#include &lt;iostream&gt;#include &lt;Python.h&gt;// C++ call Python modulebool CppCallPython()&#123; // Python initialize Py_Initialize(); if (!Py_IsInitialized()) &#123; std::cout &lt;&lt; "Python initialization failed!\n"; return false; &#125; // If my MyPython.py file is in "/Users/xx/code", set the working path to "/Users/xx/code" std::string path = "/Users/xx/code"; PySys_SetPath(&amp;path[0u]); // Import MyPython.py module PyObject* pModule = PyImport_ImportModule("MyPython"); if (!pModule) &#123; std::cout &lt;&lt;"Cannot open Python file!\n"; return false; &#125; // Get the HelloPython() function in the module PyObject* pFunhello = PyObject_GetAttrString(pModule, "HelloPython"); if (!pFunhello) &#123; std::cout &lt;&lt; "Failed to get this function!"; return false; &#125; // Call HelloPython() PyObject_CallFunction(pFunhello, NULL); // Finalize Py_Finalize(); return true;&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 使用 Qt 生成带标签数据集的 CSV 文件]]></title>
    <url>%2F2018%2F06%2F12%2FUsingQtToCreateCSV%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// C++ 使用 Qt 生成 CSV 文件// 以下函数实现生成特定类型的 CSV 文件，可用于生成带标签的数据集 CSV 文件，标签为图片上一级的文件夹名字。// 作者：huihut// 仓库：https://gist.github.com/huihut/c9f43e276ef7652f0471725482a1e4f6/*目录结构（使用 tree 命令查看）：xx@xxs-MacBook-Pro:~/code/dataset$ tree.├── README├── dataset_csv.txt├── s01│ ├── 01.pgm│ ├── ...│ └── 10.pgm├── s02│ ├── 01.pgm│ ├── ...│ └── 10.pgm...└── s10 ├── 01.pgm ├── ... └── 10.pgm-----------------------------------------------------------生成的 CSV 文件内容（使用 cat 命令查看 dataset_csv.txt 文件内容）：xx@xxs-MacBook-Pro:~/code/dataset$ cat dataset_csv.txt/Users/xx/code/dataset/s01/01.pgm,s01/Users/xx/code/dataset/s01/02.pgm,s01.../Users/xx/code/dataset/s01/10.pgm,s01/Users/xx/code/dataset/s02/01.pgm,s02/Users/xx/code/dataset/s02/02.pgm,s02.../Users/xx/code/dataset/s10/01.pgm,s10/Users/xx/code/dataset/s10/02.pgm,s10.../Users/xx/code/dataset/s10/10.pgm,s10*/#include &lt;QDir&gt;#include &lt;QDebug&gt;#include &lt;QDirIterator&gt;bool CreateCSV()&#123; // 数据集的基础路径 QString datasetdir = "/Users/xx/code/dataset"; // 生成的 CSV 文件的名字 QString csvName = "dataset_csv.txt"; // 数据集路径与数据集名字的分隔符 char separator = ','; // 数据集路径、数据集名字 QString datasetPath, datasetName; // 文件迭代器：获取指定类型（以下是 pgm、png、jpg 三种类型）的数据集文件 QDirIterator it(datasetdir, QStringList() &lt;&lt; "*.pgm" &lt;&lt; "*.png" &lt;&lt; "*.jpg", QDir::Files, QDirIterator::Subdirectories); if(!it.hasNext()) &#123; qDebug() &lt;&lt; "当前路径下数据集为空！\n"; return false; &#125; // 创建及打开 CSV 文件 QFile file(datasetdir + QDir::toNativeSeparators("/") + csvName); if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) &#123; qDebug() &lt;&lt; "打开 CSV 文件失败！\n"; return false; &#125; // 文件写的文本流 QTextStream csv_ts(&amp;file); // 文件迭代器中有指定数据集文件则依次迭代 while (it.hasNext()) &#123; // 数据集路径 datasetPath = it.next(); // 数据集名字 datasetName = datasetPath.section(QDir::toNativeSeparators("/"), -2, -2); // 写入文本流 csv_ts &lt;&lt; datasetPath &lt;&lt; separator &lt;&lt; datasetName &lt;&lt; "\n"; &#125; // 关闭文本流 file.close(); return true;&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>QT</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt GDB 无法调试 MSVC 编译的程序而报错：file format not recognized]]></title>
    <url>%2F2018%2F06%2F02%2FQtNotInExecutableFormat%2F</url>
    <content type="text"><![CDATA[环境 Windows 10 x64 Visual Studio 2017 Qt 5.11 异常Qt Debug 时提示异常： 1qt not in executable format. file format not recognized 原因编译器（Compiler）使用了 64 位版本的 MSVC，调试器（Debugger）却使用了 32 位的 MinGW 的 GDB，从而 GDB 不能调试 64 位程序而报错。 解决 在 Qt 的 工具 - 选项 - 构建和运行 - Debuggers 选择 CDB（Debugging Tools for Windows）， 不能自动检测到则手动添加，如：C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\cdb.exe， 没有 cdb 则下载：Windows Driver Kit (WDK)（下载装好后重启 Qt 一般就可以自动检测到）]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一加 3T ROM、内核、固件、Recovery、框架、软件（APP）总结]]></title>
    <url>%2F2018%2F05%2F11%2Fawesome-oneplus-3t%2F</url>
    <content type="text"><![CDATA[一加 3T ROM、内核（Kernel）、固件（Firmware）、Recovery、框架（Framework）、软件（APP），以备茶余饭后手贱刷机之用。 相关链接 Github Repository： huihut/awesome-oneplus-3t 之前的相关博文：一加3T的刷机流程及玩机一些事 ROM基于 Android 8.1 NitrogenOS | 下载 Omni 8.1 | 下载 [Official] ResurrectionRemix v6.0.0 | 下载 AOSP Extended 5.4 | 下载 LineageOS 15.1 | 下载 Havoc-OS | 下载 Validus 2.2 | 下载 AICP 13.1 | 下载 AOSiP | 下载 GZOSP 1.0 | 下载 Candy 8.1 | 下载 A.O.S.C.P : CypherOS | 官方下载 | 非官方下载 MSM Xtended | 下载 Cosmic-OS 3.1 | 下载 [Unoffical] Resurrection Remix (LuisROM) | 下载 AOKP Oreo | 下载 NLOS-15.1 beta | 下载 Tugapower | 下载 MoKee Open Source Project | 下载 crDroid | 下载 BootleggersROM | 下载 AquariOS | 下载 CarbonROM | 下载 [Unofficial] ResurrectionRemix v6.0.0 | 下载 Pixel Experience | 下载 基于 Android 8.0 [一加官方] OnePlus 3T 氧OS(OxygenOS) 5.0.1 | 下载 [一加官方] OnePlus 3T 氧OS(OxygenOS) beta 26 | 下载 [一加官方] OnePlus 3T 氢OS(H2OS) 稳定版第7版 | 下载 [一加官方] OnePlus 3T 氢OS(H2OS) 公测版第11版 | 下载 ExperienceOS (OP3 only) [OOS 5.0.1 + OB35 Based] | 下载 theOne3TOS - [OOS 5.0.1 + OB26 Based] | OOS 下载 | Open Based 下载 其他 ROM OnePlus 3T ROMs 救砖工具包（基于 Android 6.0） 一加3T (A3010/全网通) 官方恢复兼救砖 （安卓6.0） | 下载地址一 | 下载地址二 内核 Kernel Caesium - CadaverousCherry | 下载 Derp 4.0 (OOS) | 下载 Flash | 下载(OOS) | 下载(Custom) Boeffla kernel 3.0 beta 5 (OOS) | OP3T 下载 | OP3 下载 Boeffla kernel 3.0 beta 5 (LOS 15.1) | OP3T 下载 | OP3 下载 White Wolf (OOS) | OP3T 下载 White Wolf (Custom) | OP3T 下载 HolyDragon | 下载 (OOS/H2OS) | 下载 (Omni/AOSP) MadysXtended [Android 8.1 Only] | Franco Kernel | 下载 (OOS) OP3T OP3 | 下载 (Custom) OP3T OP3 固件 Firmware OP3T | [OP3T][FIRMWARE+MODEM] Open Beta 26 - Oreo | 下载 (OOS) | 下载 (Open Beta) OP3 | [FIRMWARE/MODEM] Collection - Flashable Zips! | 下载 (OOS) | 下载 (Open Beta) Recovery [一加官方] Oxygen Recovery Official TWRP 3.2.1-0 (unified) | 下载 ADB下载Windows 版 官方下载：https://dl.google.com/android/repository/platform-tools-latest-windows.zip 网盘下载链接：http://pan.baidu.com/s/1eRG8gXs 密码：72ac MacOS 版 官方下载：https://dl.google.com/android/repository/platform-tools-latest-darwin.zip 网盘下载链接：http://pan.baidu.com/s/1pLQFvrt 密码：7qav Linux 版 官方下载：https://dl.google.com/android/repository/platform-tools-latest-linux.zip 网盘下载链接：http://pan.baidu.com/s/1nu8mvrF 密码：giug 教程 How to Install ADB on Windows, macOS, and Linux 框架 FrameworkXposed下载 [zip] Xposed for Oreo | SDK26 Android 8.0 下载 | SDK27 Android 8.1 下载 [zip] Xposed Uninstaller [apk] Xposed Installer [apk] Material Design Xposed Installer | 下载 模块 Android 系统上的 Xposed 框架中都有哪些值得推荐的模块？ Magisk下载 [zip] Latest Magisk [zip] Latest Uninstaller (Support all versions) [apk] Latest Magisk Manager 模块 [教程] (搬运XDA)magisk框架教程以及模块-xposed的替代品 软件 APP应用市场 Google Play 酷安 Shadowsocks Github . shadowsocks/shadowsocks-android Google Play . Shadowsocks ShadowsocksR Github . shadowsocksr-backup/shadowsocksr-android GAPPS Open Gapps (8.0/8.1) Pixel2Mod Google Camera Pixel2Mod Google Camera Google Pixel 实时动态壁纸 [Google Pixel/2] Live Wallpapers 绿色守护 Google Play . 绿色守护 (Greenify) 酷安 . Greenify绿色守护 教程How to grant permissions required by some features on non-root device? 命令Android 7.0+ 非 root 开启嗜睡模式授权命令（其他命令见教程）： 1adb -d shell pm grant com.oasisfeng.greenify android.permission.WRITE_SECURE_SETTINGS 冰箱 Google Play . 冰箱 Ice Box —自动冻结应用 酷安 . 冰箱 Ice Box 教程冰箱免 Root（设备管理员模式）使用配置方法 命令1adb shell dpm set-device-owner com.catchingnow.icebox/.receiver.DPMReceiver 黑域 Google Play . 黑阈 酷安 . 黑阈 命令1adb -d shell sh /data/data/me.piebridge.brevent/brevent.sh 教程博文 [INFO] List of all Oreo roms/kernels/recovery for 3/3T (UPDATED : 2018-05-06) [GUIDE] OnePlus 3T: How to Unlock Bootloader | Flash TWRP | Root | Nandroid &amp; EFS Backup and More !!]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter beta 版尝鲜（在 Windows + Android Studio 与 MacOS + VS Code 的安装配置）]]></title>
    <url>%2F2018%2F03%2F13%2FFlutterBetaTaste%2F</url>
    <content type="text"><![CDATA[Flutter 是一个 Google 发布的跨平台移动 UI 框架，使用 Dart 语言开发，可以构建高质量原生 iOS 、Android 以及 Fuchsia OS 应用，并且在排版、图标、滚动、点击等方面实现零差异。 Flutter 官网 鉴于最近出了 beta 版，就来尝鲜一下吧。 本文有 Windows + Android Studio 与 MacOS + VS Code 的体验。 Windows + Android Studio获取 Flutter SDK使用 git 克隆下来 Flutter SDK 1git clone -b beta https://github.com/flutter/flutter.git 也可以使用中国的镜像，使用方法：Using Flutter in China 配置环境变量添加 flutter\bin 的完整路径到用户变量 Path，如： 1D:\code\git\flutter\bin 安装依赖打开cmd或者PowerShell，安装 1flutter doctor 安装过程可能持续比较久 为 Android Studio 安装 Flutter 插件 装好后重启 Android Studio 创建 Flutter APP 选择 File &gt; New Flutter Project 选择 Flutter application 输入应用名 flutter_app，输入 Flutter SDK 路径（如我的：D:\code\git\flutter） Finish 等待创建 创建好后，应用程序的代码在lib/main.dart 启动 Flutter APP 选择设备 Run 尝试热重载把lib/main.dart里面的字符串 &#39;You have pushed the button this many times:&#39; 改成 &#39;Hahaha, You have clicked the button this many times:&#39; 不用停止模拟器，直接 Save All（cmd-s/ ctrl-s），或者单击 Hot Reload 按钮（带有闪电图标的按钮） 就能看到模拟器中间那行字符串很快更新了。 嗯，体验还是蛮爽的！ MacOS + VS Code接下来看下在 MacOS 下的安装 获取 Flutter SDK12git clone -b beta https://github.com/flutter/flutter.gitexport PATH=`pwd`/flutter/bin:$PATH 配置环境变量打开环境变量配置文件 1sudo vi $HOME/.bash_profile 添加一行你的flutter/bin的绝对路径，如我的： 1export PATH=/Users/xx/code/git/flutter/bin:$PATH 刷新 1source $HOME/.bash_profile 验证一下是否配置好 1echo $PATH 安装依赖1flutter doctor 为 VS Code 安装 Flutter 插件在扩展商店中搜索 Dart Code 下载安装 安装好后重新打开 点击 查看 - 命令面板，搜索 Flutter: Run Flutter Doctor 如果 VS Code 找不到 Flutter SDK 路径，就点击进行配置 配置好后重新 Flutter: Run Flutter Doctor，检查配置是否成功 编译 iOS 需要 Xcode 9.0.0+接下来再检查还需要安装什么 1flutter doctor 然后突然发现。。。 要编译 iOS 应用需要 Xcode 9.0.0+ ！ 可是官网明明说的是 Xcode 7.2+ ？打脸？？ 对此，我特意把我的 Xcode 从 7.1 更新到 7.2，结果还是说需要 9.0.0+，看来是官网教程没更新了。 什么？你说为什么不更新到 Xcode 最新版？ 这个……由于博主的是黑苹果，无法升级 MacOS，现在还是 OSX 10.10.5，最高支持的 Xcode 是 7.2.1 所以只好再编译 Android 应用了，下面也只讲构建 Android 的 这里附上有编译 iOS 的教程：Flutter基础—开发环境与入门 创建并执行 Flutter APP在 VS Code 的终端（或其他终端）上跳转到要创建项目的路径，然后创建名为flutter_app的项目 1234cd ~/code/Androidflutter create flutter_appcd flutter_appflutter run 在 Windows 的时候使用的是模拟器，现在用真机体验一下 运行后，试着修改字符串 &#39;You have pushed the button this many times:&#39; 改成 &#39;yeah, You have pushed the button this many times:&#39; 保存，然后在终端按 r 热重载 r：热重载 R：重启整个APP h：帮助 q：退出APP 嗯，Cool。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub 弃用 TLS 1.0、1.1 导致 push 异常 SSL routines:SSL23_GET_SERVER_HELLO:tlsv1 alert protocol version]]></title>
    <url>%2F2018%2F02%2F28%2FGitHubAbandonedTLS1.0_1.1%2F</url>
    <content type="text"><![CDATA[报错git push 到 Github 的时候出现异常： 12fatal: unable to access &apos;https://github.com/huihut/interview.git/&apos;: error:1407742E:SSL routines:SSL23_GET_SERVER_HELLO:tlsv1 alert protocol versionPushing to https://github.com/huihut/interview.git 原因在 2018年2月22日19:00 UTC（太平洋标准时间上午11:00），GitHub 停止了对加密弱 TLS 1.0 和 1.1 协议的支持，并且仅支持与 TLS 1.2 协议的连接。 官方声明： Github . Weak cryptographic standards removal notice 因此，如果你的 git 连接方式仍然是 TLS 1.0 或 1.1，则会报错。 解决① 查看你的 TLS 版本 1git config --global --list ② 如果仍然是 TLS 1.0 或 1.1，则下载更新 Git 最新版：https://git-scm.com/ ③ 安装好最新版 Git 后，更新 TLS 12git config --global --unset http.sslVersiongit config --global --add http.sslVersion tlsv1.2 ④ 现在则可以使用 TLS 1.2 传输，并解决了此问题 操作如下图：]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个可以模仿你的表情的语音聊天机器人 —— Facemoji 废萌（OpenCV+Dlib+Live2D+图灵机器人+讯飞IAT语音听写+讯飞TTS语音合成）]]></title>
    <url>%2F2018%2F02%2F08%2FFacemoji1%2F</url>
    <content type="text"><![CDATA[概述本文介绍一个可以模仿你的表情的语音聊天机器人 —— Facemoji 废萌 这是个 Unity 项目，其暂时有两个模块 ： 【模块一】是实时人脸卡通化（FaceTracking），使用 OpenCV 和 Dlib 检测面部表情，并实时转化为 Live2D 模型，然后可 录制 成 gif 图； 【模块二】是人工智能（AI）使用 图灵机器人、讯飞IAT语音听写、讯飞TTS语音合成 进行语音聊天。 预览 源码源码：Github . huihut/Facemoji 下载 酷安 . Facemoji 废萌 Google Play (需要梯子) Github . Facemoji/releases Google云盘 . Facemoji/Platform Baidu网盘 . Facemoji/Platform 为什么叫废萌（Facemoji）首先，为什么叫废萌（Facemoji）？…emmm…这个项目其实是由 Animoji 启发的，由于当时 Animoji 没有开放 api，所以想开发个跨平台（Unity）的类似的项目，就叫 Facemoji。 至于中文名废萌嘛？…emmm…总觉得她除了卖萌没什么作用，所以就叫废（Face）萌（Moji）了。 制作 从 Google云盘 或者 Baidu网盘下载shape_predictor_68_face_landmarks.dat（已训练好的人脸检测模型）和 Facemoji_Plugins_Assets_1.5.0.unitypackage（精简的 OpenCV, Dlib, Live2D 和 Iflytek 库） 克隆下源码：git clone git@github.com:huihut/Facemoji.git 创建一个新的 Unity 项目，命名为 Facemoji 把 Facemoji-master 文件夹中的 Assets 和 ProjectSettings 替换 Facemoji 的同名文件夹 把 shape_predictor_68_face_landmarks.dat 复制到 Facemoji/Assets/StreamingAssets/ 导入 Facemoji_Plugins_Assets_1.5.0.unitypackage。导入后的文件结构如下： 转换平台到 Android（其他平台未适配） Build &amp; Run 使用实时人脸卡通化（FaceTracking）使用 OpenCV 和 Dlib 检测面部表情，并实时转化为 Live2D 模型； 她可以跟着你的头部表情动，试着摇头看看吧。 录制 gif 图点击顶部中间的录制键可以录制 3 秒的 gif； 录制状态为：Recording（准备录制）、PreProcessing（正在录制）、Paused（正在压缩成gif图） 生成的 gif 存储在 Application.dataPath，Android 平台的话在/storage/emulated/0/Android/data/com.huihut.facemoji/files/ 语音和文字聊天（聊天机器人？ 她说她是 AI，不是机器人！ hhhh…）使用 图灵机器人、讯飞 IAT 语音听写、讯飞 TTS 语音合成 她很智能（zhizhang），可以： 聊天对话 生活百科 数学计算 故事大全 笑话大全 成语接龙 星座运势 天气查询 … 但是由于她是个中国 AI（机器人），图灵机器人只支持中文，所以她只能进行中文聊天，和她讲英文她只会翻译。 不过她以后会学习英文的（换个会讲英文的）。 Gif演示 异常问题人不动时模型抖动问题（特别是眼睛眉毛）Facemoji/issues/1原因 手/眼/眉等的轻微抖动 Dlib 检测到的每一帧人脸特征点的位置会有轻微差距 解决 调整模型参数 如果人眼睛小的话，可以修改 FaceTracking.cs 中 live2DModelUpdate 方法，把睁开眼的区间改大一点，如下： 123456789// eye_open_L // 左眼float eyeOpen_L = getRaitoOfEyeOpen_L (points);if (eyeOpen_L &gt; 0.4f &amp;&amp; eyeOpen_L &lt; 1.0f) eyeOpen_L = 1; // 睁开眼else if (eyeOpen_L &gt;= 1.0f) eyeOpen_L = 2; // 睁大眼else if (eyeOpen_L &lt;= 0.4f) eyeOpen_L = 0; // 闭上眼live2DModel.PARAM_EYE_L_OPEN = eyeOpen_L; 考虑使用卡尔曼滤波器或者其他滤波器过滤（未尝试） 修改说明 2018年03月23日因项目更新 v1.5.0 版本而对此博文做了修改。因博文内容不常改动，项目部署、文档等以Github为准。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt的QVaiant中使用非QMetaType类型缺少Q_DECLARE_METATYPE宏定义错误]]></title>
    <url>%2F2017%2F12%2F05%2FQVaiantQ_DECLARE_METATYPE%2F</url>
    <content type="text"><![CDATA[报错123E:\Qt\Qt5.9.3\5.9.3\mingw53_32\include\QtCore\qglobal.h:738: error: static assertion failed: Type is not registered, please use the Q_DECLARE_METATYPE macro to make it known to Qt&apos;s meta-object system #define Q_STATIC_ASSERT_X(Condition, Message) static_assert(bool(Condition), Message) ^ 报错代码123const QCameraInfo &amp;cameraInfo...QVariant::fromValue(cameraInfo) 原因QVaiant 不能识别自定义类型和其他非 QMetaType 内置类型， 而 QCameraInfo 是非 QMetaType 内置类型，因此使用 QVariant::fromValue(cameraInfo) 之前，需要使用 Q_DECLARE_METATYPE 宏对 QCameraInfo 进行声明。 解决在代码中加个宏定义： 1Q_DECLARE_METATYPE(QCameraInfo) 总结 Q_DECLARE_METATYPE 如果要使自定义类型或其他非 QMetaType 内置类型在 QVaiant 中使用，必须使用该宏 该类型必须有公有的 构造、析构、复制构造 函数 qRegisterMetaType 必须使用该函数的两种情况 如果非 QMetaType 内置类型要在 Qt 的属性系统中使用 如果非 QMetaType 内置类型要在 queued 信号与槽 中使用 参考 Q_DECLARE_METATYPE与qRegisterMetaType学习 How to use QVariant::fromValue with QString? QMetaType Class - Q_DECLARE_METATYPE(Type)]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV使用CMake和MinGW的编译安装及其在Qt配置运行]]></title>
    <url>%2F2017%2F12%2F03%2FCompiledOpenCVRunInQt%2F</url>
    <content type="text"><![CDATA[前言本篇博文是使用 32 位的 MinGW 在 Windows 下编译 OpenCV 生成 32 位的 dll。 关于使用 64 位的 MinGW 编译 OpenCV 生成 64 位的 dll，见：OpenCV使用CMake和MinGW-w64的编译安装 编译好的 OpenCV（MinGW 版）：Github . huihut/OpenCV-MinGW-Build 软件环境 Windows-10-64bit Qt-5.9.3 MinGW-5.3.0-32bit CMake-3.9.2 OpenCV-3.3.1 / 3.4.1 / 3.4.5 / 3.4.6 / 3.4.7 (适用) OpenCV 的 MSVC 版及 MinGW 版MSVC 版下载的 OpenCV 文件夹会有： build （已编译好的库） sources （源码） 使用 MSVC 的话，直接在 1build/x64/vc14 里面就有了，配置好路径就可以使用。 MinGW 版OpenCV 没有为我们编译好 MinGW 版，所以我们只能自己编译，下面就是介绍 MinGW 版的编译流程。 也可以直接下载使用我编译好了的 OpenCV （在上文）。 安装及配置 Qt、MinGW、CMake安装CMake 自行安装，Qt 和 MinGW 可以直接使用qt-opensource-windows-x86-5.9.3.exe 安装包安装，注意选择安装的组件(components)的时候勾选 MinGW : Qt-Qt5.9-MingGW 5.3.0 32 bit Qt-Tools-MinGW 5.3.0 配置 Qt、MinGW安装好后打开 QtCreator，在工具-选项-构建和运行-构建套件，选中Desktop Qt 5.9.3 MinGW 32bit，设为默认，OK。 添加 MinGW 到环境变量为用户变量 Path 添加 E:\Qt\Qt5.9.3\Tools\mingw530_32\bin 使环境变量生效打开命令提示符 CMD，运行 set PATH=C:，更改当前窗口任务的环境变量，关闭这个 CMD。 再次打开另一个 CMD，运行 echo %PATH%，显示最新的环境变量，会发现刚刚添加的 MinGW 环境变量已经生效。 使用 CMake 生成 OpenCV 的 Makefile打开 cmake-gui，设置源码和生成路径： Where is the source code: E:/OpenCV_3.3.1/opencv/sources Where to build the binaries: E:/OpenCV_3.3.1/opencv-build 点击 Configure，设置编译器 Specify the generator for this project: MinGW Makefiles Specify native compilers Next Compilers C: E:\Qt\Qt5.9.3\Tools\mingw530_32\bin\gcc.exe Compilers C++: E:\Qt\Qt5.9.3\Tools\mingw530_32\bin\g++.exe Finish 编译配置： 勾选 WITH_QT 勾选 WITH_OPENGL 点击 Configure，再次配置： 不勾选 WITH_IPP 设置 QT_MAKE_EXECUTABLE 为 E:\Qt\Qt5.9.3\5.9.3\mingw53_32\bin\qmake.exe 设置 Qt5Concurrent_DIR 为 E:\Qt\Qt5.9.3\5.9.3\mingw53_32\lib\cmake\Qt5Concurrent 设置 Qt5Core_DIR 为 E:\Qt\Qt5.9.3\5.9.3\mingw53_32\lib\cmake\Qt5Core 设置 Qt5Gui_DIR 为 E:\Qt\Qt5.9.3\5.9.3\mingw53_32\lib\cmake\Qt5Gui 设置 Qt5Test_DIR 为 E:\Qt\Qt5.9.3\5.9.3\mingw53_32\lib\cmake\Qt5Test 设置 Qt5Widgets_DIR 为 E:\Qt\Qt5.9.3\5.9.3\mingw53_32\lib\cmake\Qt5Widgets 设置 Qt5OpenGL_DIR 为 E:\Qt\Qt5.9.3\5.9.3\mingw53_32\lib\cmake\Qt5OpenGL 设置 CMAKE_BUILD_TYPE 为 Release 或者 RelWithDebInfo 点击 Generate 生成 Makefile 编译 OpenCV打开终端进行编译：（-j 是使用 8 个线程进行编译，请根据你的计算机配置合理设置线程数） 1234E:cd E:\OpenCV_3.3.1\opencv-buildmingw32-make -j 8mingw32-make install 如果 mingw32-make -j 8 遇到错误，请看下面的 编译 OpenCV 常见错误，否则执行 mingw32-make install，完成安装。 编译 OpenCV 常见错误0. 多线程编译错误信息不明确表现如果使用了多线程编译，导致错误，但是错误信息不明确，如： 12Makefile:161: recipe for target &apos;all&apos; failedmingw32-make: *** [all] Error 2 解决使用单线程编译： 1mingw32-make 以查看详细的错误提示，再根据具体情况解决。 1. RC 错误表现1... windres.exe: unknown option -- W ... 或者 123FORMAT is one of rc, res, or coff, and is deduced from the file nameextension if not specified. A single file name is an input file.No input-file is stdin, default rc. No output-file is stdout, default rc. 解决在 cmake-gui 编译配置中： 不勾选 ENABLE_PRECOMPILED_HEADERS 然后重新 Configure-Generate-mingw32-make 2. sprintf_instead_use_StringCbPrintfA_or_StringCchPrintfA 错误表现12...opencv/sources/modules/videoio/src/cap_dshow.cpp...... &apos;sprintf_instead_use_StringCbPrintfA_or_StringCchPrintfA&apos; was not declared in this scope ... 或者 12Makefile:161: recipe for target &apos;all&apos; failedmingw32-make: *** [all] Error 2 解决修改E:\OpenCV_3.3.1\opencv\sources\modules\videoio\src\cap_dshow.cpp文件，在#include &quot;DShow.h&quot;这行的上面加一行#define NO_DSHOW_STRSAFE，如： 12#define NO_DSHOW_STRSAFE#include &quot;DShow.h&quot; 然后重新 Configure-Generate-mingw32-make 3. identifier ‘nullptr’ is a keyword in C++11 错误【2018年3月2日编译OpenCV 3.4.1时遇到并解决】表现12345678910111213D:\opencv-3.4.1\opencv-3.4.1\3rdparty\protobuf\src\google\protobuf\stubs\io_win32.cc:94:3: warning: identifier &apos;nullptr&apos; is a keyword in C++11 [-Wc++0x-compat] return s == nullptr || *s == 0; ^D:\opencv-3.4.1\opencv-3.4.1\3rdparty\protobuf\src\google\protobuf\stubs\io_win32.cc: In function &apos;bool google::protobuf::internal::win32::&#123;anonymous&#125;::null_or_empty(const char_type*)&apos;:D:\opencv-3.4.1\opencv-3.4.1\3rdparty\protobuf\src\google\protobuf\stubs\io_win32.cc:94:15: error: &apos;nullptr&apos; was not declared in this scope return s == nullptr || *s == 0; ^3rdparty\protobuf\CMakeFiles\libprotobuf.dir\build.make:412: recipe for target &apos;3rdparty/protobuf/CMakeFiles/libprotobuf.dir/src/google/protobuf/stubs/io_win32.cc.obj&apos; failedmingw32-make[2]: *** [3rdparty/protobuf/CMakeFiles/libprotobuf.dir/src/google/protobuf/stubs/io_win32.cc.obj] Error 1CMakeFiles\Makefile2:710: recipe for target &apos;3rdparty/protobuf/CMakeFiles/libprotobuf.dir/all&apos; failedmingw32-make[1]: *** [3rdparty/protobuf/CMakeFiles/libprotobuf.dir/all] Error 2Makefile:161: recipe for target &apos;all&apos; failedmingw32-make: *** [all] Error 2 解决在 cmake-gui 编译配置中： 勾选 ENABLE_CXX11 然后重新 Configure-Generate-mingw32-make 4. ‘chmod’ 不是内部或外部命令，也不是可运行的程序 或批处理文件 | ‘chmod’ is not recognized as an internal or external command【2019年9月2日编译OpenCV 3.4.7时遇到并解决】表现1&apos;chmod&apos; 不是内部或外部命令，也不是可运行的程序 或批处理文件 原因在 E:\opencv-3.4.7\opencv-3.4.7\cmake\OpenCVPCHSupport.cmake 中使用了 chmod 命令，然而 Windows 下不支持 chmod 命令，因此报错。 解决判断系统是否 Windows，若是 Windows，则不使用 COMMAND chmod +x &quot;${_pch_generate_file_cmd}&quot;，如我提的 PR 中的修改：fix ‘chmod’ is not recognized as an internal or external command in Windows #15433 修改后再重新 Configure-Generate-mingw32-make 5. test_common.hpp: No such file or directory【2019年9月2日编译OpenCV 3.4.7时遇到并解决】表现12345In file included from &lt;command-line&gt;:0:0:E:/opencv-3.4.7/opencv-3.4.7-build/modules/dnn/test_precomp.hpp:50:10: fatal error: test_common.hpp: No such file or directory #include &quot;test_common.hpp&quot; ^~~~~~~~~~~~~~~~~compilation terminated. 解决方法一：（issues/15381） 在 cmake-gui 编译配置中： 不勾选 ENABLE_PRECOMPILED_HEADERS（禁用预编译头） 然后重新 Configure-Generate-mingw32-make 方法二： 把 E:\opencv-3.4.7\opencv-3.4.7\modules\dnn\test\test_common.hpp 复制到 E:\opencv-3.4.7\opencv-3.4.7-build\modules\dnn\ 目录下 然后继续 mingw32-make 添加 OpenCV 编译的库到环境变量 为系统变量 Path 添加 E:\OpenCV_3.3.1\opencv-build\install\x86\mingw\bin 新建 OpenCV 的 Qt 项目在 .pro 文件里面添加： 1234win32 &#123;INCLUDEPATH += E:\OpenCV_3.3.1\opencv-build\install\includeLIBS += E:\OpenCV_3.3.1\opencv-build\install\x86\mingw\bin\libopencv_*.dll&#125; 或者：（区分 debug 和 release 是因为 OpenCV 对其两者有不同的库，你需要把路径改为你自己的，我编译 MinGW 的 OpenCV 只有 release 库） 1234567891011121314win32 &#123;INCLUDEPATH += E:\OpenCV_3.3.1\opencv-build\install\includeCONFIG(debug, debug|release): &#123;LIBS += E:\OpenCV_3.3.1\opencv-build\install\x86\mingw\bin\libopencv_*d.dll&#125; else:CONFIG(release, debug|release): &#123;LIBS += -LE:\OpenCV_3.3.1\opencv-build\install\x86\mingw\bin \ -llibopencv_core331 \ -llibopencv_highgui331 \ -llibopencv_imgcodecs331 \ -llibopencv_imgproc331 \ -llibopencv_features2d331 \ -llibopencv_calib3d331&#125;&#125; 然后在 MainWindow 中如下： 123456789101112131415161718192021222324#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); // read an image cv::Mat image = cv::imread(&quot;E:/Pictures/H_white.png&quot;, 1); // create image window named &quot;My Image&quot; cv::namedWindow(&quot;My Image&quot;); // show the image on window cv::imshow(&quot;My Image&quot;, image);&#125;MainWindow::~MainWindow()&#123; delete ui;&#125; 最后运行起来了，效果如图： 官方教程 How to setup Qt and openCV on Windows]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>链接装载库</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用MFC的CDC类绘制三维坐标系及球面函数]]></title>
    <url>%2F2017%2F10%2F13%2FGraphicsExercise3D%2F</url>
    <content type="text"><![CDATA[系列链接 使用MFC的CDC类绘制二维坐标系及正余弦函数 / 源码 使用MFC的CDC类绘制三维坐标系及球面函数 / 源码 概述本文使用MFC的CDC类绘制三维坐标系及球面函数。首先计算推导出三维坐标在二维平面显示的坐标变换方程（使用斜二测视图），使用球面的参数方程，然后定义图形缩放比例规模、坐标轴位移，变换坐标系和规模等，最后绘制坐标轴及球面函数。 如果对绘制二维坐标系还不太熟悉可以先看上面系列链接的：使用MFC的CDC类绘制二维坐标系及正余弦函数，本文对二维绘制及绘制函数部分不再赘述。因为二维坐标系的博文已经分模块讲解地比较清楚了，而与三维坐标系的基本思路相同，所以本文大部分直接使用注释讲解。 三维转二维的推导 上图可知，只要使用Transform3Dto2D()函数，即可方便的把三维坐标转化为二维坐标（斜二测视图）。 球面参数方程在三维空间直角坐标系中，以原点为球心、半径为 r 的球面的方程为 x^2 + y^2 + z^2 = r^2，其参数方程为 新建项目Visual Studio- 新建项目 - MFC应用程序 - 命名为GraphicsExercise3D - 确定 - 下一步 - 应用程序类型选择单个文档 - 完成 GraphicsExercise3DView.h在GraphicsExercise3DView.h添加以下内容 1234567891011121314151617// 操作public: void SetScale(int scale); void SetTransformOrigin(float transformOriginX, float transformOriginY); void SetPlotSphere(float radius, float stepPhi, float stepTheta); void SetSlantRadian(float slant); float TransformScale(float num); float TransformOriginX(float x); float TransformOriginY(float y); float TransformOriginScaleX(float x); float TransformOriginScaleY(float y); void Transform3Dto2D(float &amp;x, float &amp;y, float z);private: int scale; float radius, stepPhi, stepTheta, slant, transformOriginX, transformOriginY; GraphicsExercise3DView.cpp引入数学函数库1#include &lt;math.h&gt; 定义π123#ifndef PI#define PI 3.14159#endif // !PI 在构造函数初始化 12345678910111213141516CGraphicsExercise3DView::CGraphicsExercise3DView()&#123; // TODO: 在此处添加构造代码 // 设置斜二测视图倾斜角度（弧度制） SetSlantRadian(PI / 4); // 设置规模比例 SetScale(70); // 设置坐标系在x、y方向的位移（不改变规模情况下，即移动像素） SetTransformOrigin(300, 350); // 设置球面半径radius、取样步长stepPhi、stepTheta SetPlotSphere(2.0, 0.01, 0.1);&#125; 设置初始化参数的Set函数 1234567891011121314151617181920212223242526// 设置规模void CGraphicsExercise3DView::SetScale(int scale)&#123; this-&gt;scale = scale;&#125;// 设置坐标系原点在x、y方向的位移（不改变规模情况下，即移动像素）void CGraphicsExercise3DView::SetTransformOrigin(float transformOriginX, float transformOriginY)&#123; this-&gt;transformOriginX = transformOriginX; this-&gt;transformOriginY = transformOriginY;&#125;// 设置球面半径radius、取样步长stepPhi、stepThetavoid CGraphicsExercise3DView::SetPlotSphere(float radius, float stepPhi, float stepTheta)&#123; this-&gt;radius = radius; this-&gt;stepPhi = stepPhi; this-&gt;stepTheta = stepTheta;&#125;// 设置斜二测视图的倾斜角（单位弧度）void CGraphicsExercise3DView::SetSlantRadian(float slant)&#123; this-&gt;slant = slant;&#125; 坐标及规模变换 1234567891011121314151617181920212223242526272829// 变换规模float CGraphicsExercise3DView::TransformScale(float num)&#123; return num * scale;&#125;// 坐标系X轴方向位移float CGraphicsExercise3DView::TransformOriginX(float x)&#123; return x + transformOriginX / scale;&#125;// 坐标系y轴方向位移float CGraphicsExercise3DView::TransformOriginY(float y)&#123; return y - transformOriginY / scale;&#125;// 变换坐标系X和规模float CGraphicsExercise3DView::TransformOriginScaleX(float x)&#123; return TransformScale(TransformOriginX(x));&#125;// 变换坐标系Y和规模float CGraphicsExercise3DView::TransformOriginScaleY(float y)&#123; return -TransformScale(TransformOriginY(y));&#125; 三维坐标转化为二维坐标 123456// 使用斜二测视图，把三维坐标点转化为二维平面上的点void CGraphicsExercise3DView::Transform3Dto2D(float &amp;x, float &amp;y, float z)&#123; x = x - (z * cos(slant)) / 2; y = y - (z * sin(slant)) / 2;&#125; 绘制坐标轴及函数图形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// CGraphicsExercise2View 绘制void CGraphicsExercise3DView::OnDraw(CDC* pDC)&#123; CGraphicsExercise3DDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); if (!pDoc) return; // TODO: 在此处为本机数据添加绘制代码 float x, y, z; // -------------------- 绘制坐标系 ------------------------- // 坐标x轴 pDC-&gt;MoveTo(TransformOriginScaleX(0), TransformOriginScaleY(0)); pDC-&gt;LineTo(TransformOriginScaleX(radius + 2), TransformOriginScaleY(0)); // 坐标y轴 pDC-&gt;MoveTo(TransformOriginScaleX(0), TransformOriginScaleY(0)); pDC-&gt;LineTo(TransformOriginScaleX(0), TransformOriginScaleY(radius + 2)); // 坐标z轴 x = 0, y = 0; Transform3Dto2D(x, y, radius + 5); pDC-&gt;MoveTo(TransformOriginScaleX(0), TransformOriginScaleY(0)); pDC-&gt;LineTo(TransformOriginScaleX(x), TransformOriginScaleY(y)); // 坐标x轴的箭头 pDC-&gt;MoveTo(TransformOriginScaleX(radius + 1.8), TransformOriginScaleY(0.2)); pDC-&gt;LineTo(TransformOriginScaleX(radius + 2), TransformOriginScaleY(0)); pDC-&gt;LineTo(TransformOriginScaleX(radius + 1.8), TransformOriginScaleY(-0.2)); // 坐标y轴的箭头 pDC-&gt;MoveTo(TransformOriginScaleX(-0.2), TransformOriginScaleY(radius + 1.8)); pDC-&gt;LineTo(TransformOriginScaleX(0), TransformOriginScaleY(radius + 2)); pDC-&gt;LineTo(TransformOriginScaleX(0.2), TransformOriginScaleY(radius + 1.8)); // 坐标z轴的箭头 x = 0, y = 0.2; Transform3Dto2D(x, y, radius + 5 - 0.2); pDC-&gt;MoveTo(TransformOriginScaleX(x), TransformOriginScaleY(y)); x = 0, y = 0; Transform3Dto2D(x, y, radius + 5); pDC-&gt;LineTo(TransformOriginScaleX(x), TransformOriginScaleY(y)); x = 0.2, y = 0; Transform3Dto2D(x, y, radius + 5 - 0.2); pDC-&gt;LineTo(TransformOriginScaleX(x), TransformOriginScaleY(y)); // -------------------- 绘制刻度线 ------------------------- // 绘制x轴刻度线 for (float scaleX = 0.2; scaleX &lt; radius + 1; scaleX += 0.2) &#123; pDC-&gt;MoveTo((int)TransformOriginScaleX(scaleX), (int)TransformOriginScaleY(0)); pDC-&gt;LineTo((int)TransformOriginScaleX(scaleX), (int)TransformOriginScaleY(0.1)); &#125; // 绘制y轴刻度线 for (float scaleY = 0.2; scaleY &lt;= radius + 1; scaleY += 0.2) &#123; pDC-&gt;MoveTo((int)TransformOriginScaleX(0), (int)TransformOriginScaleY(scaleY)); pDC-&gt;LineTo((int)TransformOriginScaleX(0.1), (int)TransformOriginScaleY(scaleY)); &#125; // 绘制z轴刻度线 for (float x = 0, y = 0, scaleZ = 0.2; scaleZ &lt;= radius + 4; scaleZ += 0.2, x = 0, y = 0) &#123; Transform3Dto2D(x, y, scaleZ); pDC-&gt;MoveTo((int)TransformOriginScaleX(x), (int)TransformOriginScaleY(y)); pDC-&gt;LineTo((int)TransformOriginScaleX(x + 0.1), (int)TransformOriginScaleY(y)); &#125; // -------------------- 绘制文字 ------------------------- // 绘制x轴的x pDC-&gt;TextOutW(TransformOriginScaleX(radius + 1.6), TransformOriginScaleY(-0.2), CString(&quot;x&quot;)); // 绘制y轴的y pDC-&gt;TextOutW(TransformOriginScaleX(-0.2), TransformOriginScaleY(radius + 1.6), CString(&quot;y&quot;)); // 绘制z轴的z x = 0.2, y = 0; Transform3Dto2D(x, y, radius + 5 - 0.4); pDC-&gt;TextOutW(TransformOriginScaleX(x), TransformOriginScaleY(y), CString(&quot;z&quot;)); CString s; // 绘制x轴刻度文字 for (float ScaleTextX = 0.4; ScaleTextX &lt; radius + 1; ScaleTextX += 0.4) &#123; s.Format(_T(&quot;%.1f&quot;), ScaleTextX); pDC-&gt;TextOutW(TransformOriginScaleX(ScaleTextX - 0.1), TransformOriginScaleY(-0.1), s); &#125; // 绘制y轴刻度文字 for (float ScaleTextY = 0.4; ScaleTextY &lt;= radius + 1; ScaleTextY += 0.4) &#123; s.Format(_T(&quot;%.1f&quot;), ScaleTextY); pDC-&gt;TextOutW(TransformOriginScaleX(-0.4), TransformOriginScaleY(ScaleTextY + 0.1), s); &#125; // 绘制z轴刻度文字 for (float ScaleTextZ = 0.6; ScaleTextZ &lt;= radius + 4; ScaleTextZ += 0.6) &#123; s.Format(_T(&quot;%.1f&quot;), ScaleTextZ); x = 0, y = 0; Transform3Dto2D(x, y, ScaleTextZ); pDC-&gt;TextOutW(TransformOriginScaleX(x + 0.15), TransformOriginScaleY(y + 0.12), s); &#125; // 绘制函数图的Title x = 0, y = 0; Transform3Dto2D(x, y, radius + 5); pDC-&gt;TextOutW(TransformOriginScaleX(x + 3), TransformOriginScaleY(y), CString(&quot;x^2 + y^2 + z^2 = r^2&quot;)); // -------------------- 绘制函数 ------------------------- // 球面 float phi, theta; for (phi = 0; phi &lt; 2 * PI; phi += stepPhi) &#123; for (theta = 0; theta &lt; PI; theta += stepTheta) &#123; x = radius * sin(phi) * cos(theta); y = radius * sin(phi) * sin(theta); z = radius * cos(phi); Transform3Dto2D(x, y, z); srand(z); pDC-&gt;SetPixel(TransformOriginScaleX(x), TransformOriginScaleY(y), RGB(rand() % 255, rand() % 255, rand() % 255)); &#125; &#125; //// 三棱锥（测试用） //x = 1, y = 0, z = 0; //Transform3Dto2D(x, y, z); //pDC-&gt;MoveTo((int)TransformOriginScaleX(x), (int)TransformOriginScaleY(y)); //x = 0, y = 1, z = 0; //Transform3Dto2D(x, y, z); //pDC-&gt;LineTo((int)TransformOriginScaleX(x), (int)TransformOriginScaleY(y)); //x = 0, y = 0, z = 1; //Transform3Dto2D(x, y, z); //pDC-&gt;LineTo((int)TransformOriginScaleX(x), (int)TransformOriginScaleY(y)); //x = 1, y = 0, z = 0; //Transform3Dto2D(x, y, z); //pDC-&gt;LineTo((int)TransformOriginScaleX(x), (int)TransformOriginScaleY(y));&#125; 效果图]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用MFC的CDC类绘制二维坐标系及正余弦函数]]></title>
    <url>%2F2017%2F10%2F13%2FGraphicsExercise2D%2F</url>
    <content type="text"><![CDATA[系列链接 使用MFC的CDC类绘制二维坐标系及正余弦函数 / 源码 使用MFC的CDC类绘制三维坐标系及球面函数 / 源码 概述本文使用MFC的CDC类绘制二维坐标系及正余弦函数，可以进行坐标变换、规模变换，可以设置绘制的函数。通过输入自变量的范围及步长，绘制出相应的函数图形。 新建项目Visual Studio- 新建项目 - MFC应用程序 - 命名为CGraphicsExercise2D - 确定 - 下一步 - 应用程序类型选择单个文档 - 完成 绘制函数Visual Studio为我们创建了很多无用的代码，而我们的绘制函数在在CGraphicsExercise2DView.cpp的 void CGraphicsExercise2DView::OnDraw(CDC* /*pDC*/) { CGraphicsExercise2DDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); if (!pDoc) return; // TODO: 在此处为本机数据添加绘制代码 } 取消pDC的注释，变成 void CGraphicsExercise2DView::OnDraw(CDC* pDC) 在 // TODO: 在此处为本机数据添加绘制代码 下面编写你自己的程序，如画一条线： pDC-&gt;MoveTo(20, 30); // 画笔移到从左上角往右20像素、往下30像素 pDC-&gt;LineTo(100, 100); // 画一条线到右100、下100的位置 运行下看下效果吧！ 现在删掉上面两行那条线，开始正式编写二维坐标系了。 规模变换函数上面的MoveTo(20, 30)中的20、30是在显示器上的像素点，如果绘制的坐标系是以像素为大小的话，那1、2这样小的单位在显示器上就难以看到，因此需要规模变换。通常是把小单位乘上放大规模（倍数）就可以了。 在CGraphicsExercise2DView.h public: void SetScale(int scale); float TransformScale(float num); private: int scale; 在CGraphicsExercise2DView.cpp // 设置规模 void CGraphicsExercise2DView::SetScale(int scale) { this-&gt;scale = scale; } // 变换规模 float CGraphicsExercise2DView::TransformScale(float num) { return num * scale; } 并在CGraphicsExercise2DView()函数添加 // 设置规模比例 SetScale(70); 变换坐标和规模在CGraphicsExercise2DView.h public: float TransformCoordinateScaleX(float x); float TransformCoordinateScaleY(float y); 在CGraphicsExercise2DView.cpp // 变换x的坐标和规模 float CGraphicsExercise2DView::TransformCoordinateScaleX(float x) { return TransformScale(x + 2); } // 变换y的坐标和规模 float CGraphicsExercise2DView::TransformCoordinateScaleY(float y) { return TransformScale(y + 4); } 设置绘制的函数类型在CGraphicsExercise2DView.h 类外面定义 // 支持绘制的函数类型 enum Function { Sin, Cos }; 类里面定义 public: void SetDrawFunction(Function fun); private: Function fun; 在GraphicsExerciseView.cpp #include &lt;math.h&gt; // 设置绘制的函数 void CGraphicsExercise2DView::SetDrawFunction(Function fun) { this-&gt;fun = fun; } 并在CGraphicsExercise2DView()函数添加 // 设置绘制的函数 SetDrawFunction(Sin); 函数范围和步长设置正余弦函数的x取值范围如[0, 2*π]，设置x的取样步长如0.01。 在CGraphicsExercise2DView.h public: void SetPlotSin(float startX, float endX, float step); private: float startX, endX, step; 在CGraphicsExercise2DView.cpp // 设置范围和步长 void CGraphicsExercise2DView::SetPlotSin(float startX, float endX, float step) { this-&gt;startX = startX; this-&gt;endX = endX; this-&gt;step = step; } 并在CGraphicsExercise2DView()函数添加 // 设置自变量x范围[startX, endX]、取样步长step SetPlotSin((float)0.0, (float)6.3, (float)0.01); 绘制坐标系坐标系是距离左上角右下各2 * 规模个像素开始绘制的（即y轴的顶点是（2 * 放大规模, 2 * 放大规模）） 在OnDraw()函数的// TODO: 在此处为本机数据添加绘制代码下面添加如下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// -------------------- 绘制坐标系 -------------------------float endPointX = 2 + endX + 2;// 坐标y轴pDC-&gt;MoveTo((int)TransformScale(2), (int)TransformScale(2));pDC-&gt;LineTo((int)TransformScale(2), (int)TransformScale(6));// 坐标x轴pDC-&gt;MoveTo((int)TransformScale(2), (int)TransformScale(4));pDC-&gt;LineTo((int)TransformScale(endPointX), (int)TransformScale(4));// 坐标y轴的箭头pDC-&gt;MoveTo((int)TransformScale((float)1.8), (int)TransformScale((float)2.2));pDC-&gt;LineTo((int)TransformScale(2), (int)TransformScale(2));pDC-&gt;LineTo((int)TransformScale((float)2.2), (int)TransformScale((float)2.2));// 坐标x轴的箭头pDC-&gt;MoveTo((int)TransformScale(endPointX - (float)0.2), (int)TransformScale((float)3.8));pDC-&gt;LineTo((int)TransformScale(endPointX), (int)TransformScale(4));pDC-&gt;LineTo((int)TransformScale(endPointX - (float)0.2), (int)TransformScale((float)4.2));// -------------------- 绘制刻度线 -------------------------// 绘制y轴刻度线for (float scaleY = 3; scaleY &lt;= 5; scaleY += 0.2)&#123; pDC-&gt;MoveTo((int)TransformScale(2), (int)TransformScale(scaleY)); pDC-&gt;LineTo((int)TransformScale((float)2.1), (int)TransformScale(scaleY));&#125;// 绘制x轴刻度线for (float scaleX = 2.2; scaleX &lt; endPointX - 1; scaleX += 0.2)&#123; pDC-&gt;MoveTo((int)TransformScale(scaleX), (int)TransformScale(4)); pDC-&gt;LineTo((int)TransformScale(scaleX), (int)TransformScale(3.9));&#125;// -------------------- 绘制文字 -------------------------// 绘制y轴的ypDC-&gt;TextOutW((int)TransformScale(1.8), (int)TransformScale(2.3), CString(&quot;y&quot;));// 绘制x轴的xpDC-&gt;TextOutW((int)TransformScale(endPointX - (float)0.5), (int)TransformScale(4.1), CString(&quot;x&quot;));CString s;// 绘制y轴刻度文字for (float ScaleTextY = 2.9, text = 1.0; ScaleTextY &lt;= 4.9; ScaleTextY += 0.2, text -= 0.2)&#123; s.Format(_T(&quot;%.1f&quot;), text); pDC-&gt;TextOutW((int)TransformScale(1.6), (int)TransformScale(ScaleTextY), s);&#125;// 绘制x轴刻度文字for (float ScaleTextX = 2.3; ScaleTextX &lt; endPointX - 1; ScaleTextX += 0.4)&#123; s.Format(_T(&quot;%.1f&quot;), ScaleTextX - 1.9); pDC-&gt;TextOutW((int)TransformScale(ScaleTextX), (int)TransformScale(4.1), s);&#125;// 绘制函数图的Title// 判断调用的函数switch (fun)&#123;case Sin: pDC-&gt;TextOutW((int)TransformScale(4), (int)TransformScale(6), CString(&quot;y = sin( x )&quot;)); break;case Cos: pDC-&gt;TextOutW((int)TransformScale(4), (int)TransformScale(6), CString(&quot;y = cos( x )&quot;)); break;default: break;&#125; 绘制函数x从startX绘制到endX，每间隔step绘制一次。 也是在OnDraw()函数下面添加 1234567891011121314151617181920212223// -------------------- 绘制函数 -------------------------// 不改变坐标和规模的xyfloat x, y;for (x = startX; x &lt;= endX; x += step)&#123; // 判断调用的函数 switch (fun) &#123; case Sin: y = (float)sin(x); break; case Cos: y = (float)cos(x); break; default: break; &#125; // 对xy改变坐标和规模再显示点 pDC-&gt;SetPixel((int)TransformCoordinateScaleX(x), (int)TransformCoordinateScaleY(y), 0);&#125; 效果图]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决源码编译 ZeroC Ice 缺失 mcpp、bzip2、expat 库的问题]]></title>
    <url>%2F2017%2F09%2F06%2FCompileIceMissingLibrary%2F</url>
    <content type="text"><![CDATA[缺失 mcpp 库报错/usr/bin/ld: cannot find -lmcpp 解决 下载最新的 nux-dextop-release*rpm 包 http://li.nux.ro/download/nux/dextop/el7/x86_64/ 安装 nux-dextop-release 包 sudo rpm -Uvh nux-dextop-release*rpm 安装 mcpp sudo yum install libmcpp-devel 缺失 bzip2 库报错src/Ice/ConnectionI.cpp:32:21: fatal error: bzlib.h: No such file or directory # include &lt;bzlib.h&gt; ^ compilation terminated. make: *** [src/Ice/build/x64/shared/pic/ConnectionI.o] Error 1 解决sudo yum install bzip2-devel 缺失 expat 库报错src/IceXML/Parser.cpp:12:19: fatal error: expat.h: No such file or directory #include &lt;expat.h&gt; ^ compilation terminated. make: *** [src/IceXML/build/x64/shared/pic/Parser.o] Error 1 解决sudo yum install expat-devel]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>链接装载库</tag>
        <tag>ZeroC-Ice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一加3T的刷机流程及玩机一些事]]></title>
    <url>%2F2017%2F08%2F27%2FOneplus3TBrushAndPlay%2F</url>
    <content type="text"><![CDATA[前言本文主要聊聊一加3T卡刷第三方Rom，包括刷 TWRP 的 Recovery，卡刷流程，初始化，安装及使用Xposed框架和Magisk框架。 选择Rom刷机前要选择要刷的系统，即选择Rom。 Rom无非官方Rom或者第三方Rom。 官方Rom有氢OS(H2OS)、氧OS(OxygenOS)。第三方Rom就很多了，如MIUI、Flyme、CM、AICP、LineageOS等等。 官方Rom一般比较稳定、适配性好、能接收推送；第三方Rom一般自定义程度高、可玩性高。 若是不想折腾还是官方Rom好；喜欢尝鲜可以试试第三方Rom。 官方Rom一加官方Rom有氢OS(H2OS)和氧OS(OxygenOS)。氢OS(H2OS)主要面向国内，本土化定制；氧OS(OxygenOS)主要面向国外，预装谷歌服务。官方Rom无论线刷还是卡刷都比较简单方便，在此就不做过多介绍。 氢OS(H2OS)下载：H2OS官方下载 氧OS(OxygenOS)下载：OxygenOS官方下载 第三方Rom本文主要聊聊一加3T卡刷第三方Rom。 第三方Rom在各大玩机论坛/Rom平台都能看到，如 官方论坛（推荐） xda-developers（推荐） 机锋Rom ROM之家 … 如一加3T的 一加社区 . 一加手机3T xda-developers . OnePlus 3T ROMs 我选了个OnePixel，这是个基于氧OS的类Pixel版Rom，喜欢原生的朋友可以给你的爱机食用： [ROM][EAS][DEODEXED][OB13] OnePixel, OOS Based Custom Rom with Pixel Experience 效果图 安装 TWRP因为一加官方 Recovery 功能较弱，所以先刷个 TWRP Recovery。 下载 TWRP选择自己机型的TWRP下载 https://twrp.me/Devices/ 如我的一加3T下载的TWRP文件为： twrp-3.1.1-2-oneplus3t.img 安装 ADB安装 ADB 可以使用一些一键安装工具（如：15秒ADB安装器）或者下载官方 Android SDK 的 platform-tools 启用USB调试不管哪种方式都需要首先将手机连上电脑，启用USB调试。 设置 &gt; 开发人员选项 &gt; USB调试 使用15秒ADB安装器安装 作者发的帖子: [TOOL] [WINDOWS] ADB, Fastboot and Drivers - 15 seconds ADB Installer v1.4.3 国内百度云盘下载： 链接：http://pan.baidu.com/s/1c1FWmTM 密码：vg0g 使用 Android SDK 的 platform-tools 安装下载 platform-toolsWindows版 官方下载：https://dl.google.com/android/repository/platform-tools-latest-windows.zip 网盘下载链接：http://pan.baidu.com/s/1eRG8gXs 密码：72ac MacOS版 官方下载：https://dl.google.com/android/repository/platform-tools-latest-darwin.zip 网盘下载链接：http://pan.baidu.com/s/1pLQFvrt 密码：7qav Linux版 官方下载：https://dl.google.com/android/repository/platform-tools-latest-linux.zip 网盘下载链接：http://pan.baidu.com/s/1nu8mvrF 密码：giug 安装解压，进入 platform-tools 目录 把twrp-3.1.1-2-oneplus3t.img文件复制到platform-tools目录下，终端使用 adb reboot bootloader 进入bootloader模式，输入命令 fastboot flash recovery twrp-3.1.1-2-oneplus3t.img 进行安装TWRP。 刷机（卡刷）Wipe - 清理系统和缓存进入TWRP后，首先Wipe 进入Wipe - Advanced Wipe 勾选 Dalvik/ART Cache Cache Data System 划过 Swipe to Wipe 来 Wipe 注：下面两个不用勾选 Internal Storage 是数据存放的地方 USB-OTG 是与支持USB-OTG设备的连接 Install - 安装Rom连上电脑在TWRP模式下，把下载的Rom拷贝到Internal Storage，然后在Install里面找到你的Rom，如 OnePixel_OB13_oneplus3t-7.1.1rc.zip 划过Swipe to confirm Flash进行安装，装好后重启进入系统。 初始化设置进入系统后进行初始化设置 注意：WiFi/数据连接没代理不要连接，断网设置，不然会一直连接不上Google而卡在那里的。 初始化好之后设置了些东西就是这样子啦 Xposed框架大名鼎鼎的Xposed框架，可以通过添加各种模块实现各种功能，不过官方版现在才更新到适配Android6.0 官方链接：Xposed Installer 好在XDA社区有 Material Design 版的Xposed框架下载器（推荐） xda-developers . Material Design Xposed Installer 安装 Material Design Xposed Installer 后在 UnOfficial 这栏选择适合自己手机型号的Xposed框架下载 装好Xposed框架后，下载Xposed模块 知乎上有些好的Xposed模块推荐 知乎 . Android 系统上的 Xposed 框架中都有哪些值得推荐的模块？ Magisk框架Magisk是类似xposed的第三方应用接口，但是暂时模块较少。 Magisk的介绍、下载、安装 [2017.7.20] Magisk v13.3 - Root &amp; Universal Systemless Interface [Android 5.0+] 下面是安利Magisk的帖子，里面有各种模块介绍： [教程] (搬运XDA)magisk框架教程以及模块-xposed的替代品 我因为OnePixel Rom自带Magisk，也就顺便装了个Pixel Launcher transparent dock，让pixel luncher底栏的颜色变透明。 效果如上面初始化设置那里的截图。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过直接添加或者手动编译添加库，解决 library not found for -lxxx 等的问题]]></title>
    <url>%2F2017%2F08%2F23%2FAddLibraryToSolveLibraryNotFound%2F</url>
    <content type="text"><![CDATA[前言本文基本上能完美解决这种库文件无法找到问题。 文中以IceUtil库为例子，你可以推广到其他库，方法相同。 问题描述在 Mac 下用 Homebrew 安装 ZeroC Ice 这个中间件后发现 IceUtil 库缺失，IDE 报了个链接错误，如下图： 问题分析这个问题是说链接器在链接的时候找不到 IceUtil 这个库，那我们就告诉它（添加库的路径），让它找到就好啦！ 扩展： 静态库无法链接报错： library not found for -lxxx 动态库无法装载报错： dyld: library not loaded …/libxxx.dylib 解决办法方法一：直接添加库通常解决办法是：库存在，直接添加路径。 也就是通常遇到这个问题的时候，库是已经编译安装好了的，但是 IED 不能找到。这样的话就直接添加库的路径就好了。 第一步：找库第一步，自己找到这个库。 库一般放在系统默认处或者安装到特定地方。 Linux 系统默认库放在： /lib /usr/lib /usr/local/lib ... 安装到特定地方，如我 Mac 的用 Homebrew 安装到： /usr/local/Cellar/ice/3.7.0/lib 第二步：添加路径添加库一般以下三种方法任选其一： 系统环境变量添加 系统级：修改/etc/profile或者/etc/bashrc 用户级：修改~/.bashrc或者~/.bash_profile #添加库的bin文件夹路径 export PATH =$PATH:$HOME/bin #添加到gcc头文件 export C_INCLUDE_PATH=$C_INCLUDE_PATH:/MyLib #添加到g++头文件路径 export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/MyLib #添加到动态库 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/MyLib #添加到静态库 export LIBRARY_PATH=$LIBRARY_PATH:/MyLib IED 编译环境添加 因 IDE 不同而不同，如 Qt 在项目-构建设置-构建环境处添加 具体请参考：QT 无法链接动态库 dyld library not loaded … libhdf5.100.dylib 代码添加 # 如 Qt pro 文件添加 LIBS += -L/usr/local/Cellar/ice/3.7.0/lib -lIceUtil 这样，IDE就能找到库啦！ 方法二：手动编译添加库若是你的库不存在，也就是说安装的时候没有编译生成这个库文件或者安装后莫名的不见了，这样只能重新安装或者手动编译添加库。以下讲手动编译添加库。 思路是：找库，如果找不到，手动编译生成库文件，拷贝到库文件目录，用上面添加路径的方法添加路径让IDE找到。 第一步：找库对的，还是要找找的，不然怎么知道没有呢！[捂脸] 可以在一些常放库的文件夹下找，尽量靠近根目录，如： sudo find /usr -name &quot;libIceUtil*&quot; 扩展： 如果找到名为libIceUtil.3.7.0.a的库，但是找不到libIceUtil.a的库，可以试着拷贝libIceUtil.3.7.0.a库成名为libIceUtil.a的库 cp ./libIceUtil.3.7.0.a ./libIceUtil.a 这个方法适用于： 同版本下，缺失没版本号的库文件 不同版本下，库文件没因为版本的改变而发生改变 第二步，手动编译#因为IceUtil是Ice的库，所以克隆下Ice来 git clone https://github.com/zeroc-ice/ice.git #因为我需要的是C++版 cd ice/cpp #直接编译 make 编译好后就能找到这个库了：cpp/lib/libIceUtil.a 其他库请参考官方的编译安装教程 附：Building Ice for C++ on macOS 第三步，拷贝库到安装后的文件夹到ice/cpp/lib目录下： cp ./libIceUtil.a /usr/local/Cellar/ice/3.7.0/lib 第四步：添加路径上面已经说了三种方法，这里直接代码添加： # 如 Qt pro 文件添加 LIBS += -L/usr/local/Cellar/ice/3.7.0/lib -lIceUtil 这样就解决了！ 唠叨以上这些方法基本上能完美解决这种库文件无法找到问题，如果有本文没有提及的欢迎留言讨论。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>链接装载库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal 源码编译运行 Missing cached shader map... 的问题]]></title>
    <url>%2F2017%2F07%2F28%2FUnrealMissingCachedShaderMap%2F</url>
    <content type="text"><![CDATA[Unreal 源码编译运行 Missing cached shader map… 的问题问题描述Unreal 源码是 Github-release 分支，版本是4.16。 编译运行Unreal引擎源码的时候，出现虚幻编辑器的窗口，但是卡在45%不动。 并在调试窗口输出： Missing cached shader map for material WorldGridMaterial, compiling. Is special engine material. 同类问题同样这个问题，在unrealengine社区有人遇到，但没有说明具体原因及解决方案。 answers.unrealengine.com - UE4.7 source build, missing cached shader 结果结果我没有进行任何操作，再等会儿 居然成功运行了起来！ 我猜测可能是WorldGridMaterial这个材质需要联网下载，然后由于网络问题在45%处卡住了一会儿。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Unreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Launcher 启动 UE4 引擎出现 An Unreal process has crashed 的问题]]></title>
    <url>%2F2017%2F07%2F28%2FAnUnrealProcessHasCrashed%2F</url>
    <content type="text"><![CDATA[Launcher 启动 UE4 引擎出现 An Unreal process has crashed 的问题问题描述在 Launcher 启动 UE4 引擎，引擎奔溃，出现奔溃报告： An Unreal process has crashed:UE4-…… 解决以管理员身份运行 Launcher，并启动 UE4 引擎则能正常启动。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Unreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcc/mpicc 编译器 undefined reference to ... 问题的解决]]></title>
    <url>%2F2017%2F07%2F18%2FUndefinedReferenceTo%2F</url>
    <content type="text"><![CDATA[描述我的代码中使用了libcstl库，在代码中声明： #include &lt;cstl/cmap.h&gt; 可是出现这个问题，无法识别libcstl库里调用的函数，如下图： 猜想 #include &lt;cstl/cmap.h&gt;这句话不报错说明库已经装好，环境变量也没有问题。 可能是链接时的错误。 解决查看Makefile文件发现忘记添加cstl的链接库了。 -lcstl 原来的代码是： mpicc -c main.c -std=c99 -lstdc++ -fopenmp -lm -o main.o 应该改为： mpicc -c main.c -std=c99 -lcstl -lstdc++ -fopenmp -lm -o main.o 如上图，改好之后就解决了！]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>链接装载库</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[std::map error: implicit instantiation of undefined template 不能识别std::map迭代器指针]]></title>
    <url>%2F2017%2F07%2F17%2FStdMapTheIteratorPointerIsNotRecognized%2F</url>
    <content type="text"><![CDATA[std::map error: implicit instantiation of undefined template 不能识别std::map迭代器指针代码如下： std::map&lt;std::string, int&gt;::iterator map_iter; map_iter-&gt;first QT中报错： /Applications/Xcode-beta.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/utility:258: error: implicit instantiation of undefined template &apos;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;&apos; _T1 first; ^ 发现是引入头文件错误。 我原本头文件引入如下： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;map&gt; 应该 #include &lt;string&gt;，而不是 #include &lt;string.h&gt;，修改为如下： #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT QDialog 中模态与非模态对话框的研究]]></title>
    <url>%2F2017%2F06%2F29%2FQTQDialogModal%2F</url>
    <content type="text"><![CDATA[模态与非模态对话框模态对话框模态对话框是只能首先对其进行操作后才能操作其他窗口的对话框。实质是父线程在子线程创建这个模态对话框后，父线程阻塞，等待子线程的操作。 非模态对话框非模态对话框则是可以同时对它和其他窗口进行操作的对话框。实质是父子进程并行运行。 QDialog概述 The QDialog class is the base class of dialog windows. QDialog 类是对话框窗口的基类。用于创建对话窗口。 继承关系class Q_WIDGETS_EXPORT QDialog : public QWidget QT 窗口模态模态种类enum WindowModality { NonModal, WindowModal, ApplicationModal }; 状态 Constant Value 描述 QDialog代表方法 非模态 Qt::NonModal 0 窗口不是模态，不会阻止其他窗口的操作 QDialog::show() 窗口模态 Qt::WindowModal 1 窗口对单个窗口层次结构是模态，会阻止对其所有长辈（父窗口、祖父窗口、他们的兄弟姐妹）的操作，其子窗口不会阻止 QDialog::open() 应用模态 Qt::ApplicationModal 2 窗口对应用程序是模态，并阻止对所有窗口的操作 QDialog::exec() 注意：窗口模态与应用模态都属于模态，只是WindowModal对局部模态，ApplicationModal对整个程序模态。 设置模态定义class Q_WIDGETS_EXPORT QWidget : public QObject, public QPaintDevice { public: void setWindowModality(Qt::WindowModality windowModality); } 使用QDialog dialog; dialog.setWindowModality(Qt::ApplicationModal);]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT 无法链接动态库 dyld library not loaded ... libhdf5.100.dylib]]></title>
    <url>%2F2017%2F06%2F05%2FQtDyldLibraryNotLoaded%2F</url>
    <content type="text"><![CDATA[qt dyld library not loaded …/libhdf5.100.dylib 分析无法链接动态库，考虑手动添加链接。 找到 libhdf5.100.dylib 文件及路径 /usr/local/opt/hdf5/lib 添加到 QT Run Environment把路径添加到Run Environment中的DYLD_LIBRARY_PATH变量的值中。 若无此变量则添加，若已有则按编辑并在后面加上路径。 Run! 补充：添加到构建设置-构建环境中如果添加到 Run Environment 中还是不行，可以添加到Build-构建设置-构建环境中。 Debug! Thanksstackoverflow . qt mac osx 10.8 dyld: library not loaded…image not found]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>链接装载库</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 构建静态文件无法生成 index.html 等文件]]></title>
    <url>%2F2017%2F05%2F13%2FHexoNPMERR%2F</url>
    <content type="text"><![CDATA[hexo g 无法生成 index构建情况如下图： 但是一些文件没有生成，如 index.html 文件。 查看 npm 安装各 hexo 插件的情况npm ls --depth 0 hexo 的一些插件未安装插件npm ERR! missing npm ERR! missing hexo-generator-archive… 解决逐一安装缺失的包 npm install hexo-generator-archive --save ... 安装完后重新构建即可解决。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CloudCompare插件编写一（插件框架）]]></title>
    <url>%2F2017%2F04%2F27%2FCloudCompareSAFPlugin_1_Framework%2F</url>
    <content type="text"><![CDATA[唠叨本文唠叨了些CloudComapre这个开源软件的插件编写。 虽然这篇是入门教程，但是作为一只有梦想的程序猿，怎能像很多入门教程那样写个残缺的入门教程呢！ 所以这是一个完整插件的入门教程，我们要写的插件是qSAF(Scan Angle Filter)，这是可以过滤给定范围内点的扫描角度的插件。 下面分三篇来介绍，分别是插件框架篇、数据结构篇、算法实现篇。 这是第一篇，插件框架篇，你可以根据本文改成自己的插件，待卿临幸。 特别注意：本文的CloudCompare源码构建的是Qt工程并使用Qt Creator开发，并不是Visual Studio。 qSAF源码：Github . qSAF CloudComapreCloudComapre是一个开源的3D点云和网格的处理软件，开可以处理各类点云格式的数据。 官网：http://www.cloudcompare.org/ Github：https://github.com/cloudcompare/cloudcompare CloudComapre插件编写使用qDummyPlugin插件模板创建自己的插件【2018年5月30日改：现在Github上CloudComapre仓库的master分支已经移除qDummyPlugin插件，取而代之的是 ExamplePlugin插件： CloudCompare/plugins/example/ExamplePlugin ，原qDummyPlugin插件可在2.9.x分支或者其他早期分支上找到：qDummyPlugin】 首先在Github上git下CloudComapre的源码， 再到 CloudComapre/plugins/qDummyPlugin 下 这个qDummyPlugin就是个插件的模板，用它来写自己的插件。 我们把这个模板插件文件夹拷贝一份，改为自己的插件名qSAF（当然，你也可以改为其他你喜欢的，以下不做累述） 现在qSAF里面有如下几个文件 我们需要做的是把里面的qDummyPlugin及类似的名字改为自己的qSAF。 注意：文件名和文件里面内容都要修改！ 如： 原本CMakeLists.txt文件里面是这样的： cmake_minimum_required(VERSION 3.0) #REPLACE ALL &apos;DUMMY&apos; OCCURENCES BY YOUR PLUGIN NAME #AND ADAPT THE CODE BELOW TO YOUR OWN NEEDS! option( INSTALL_QDUMMY_PLUGIN &quot;Check to install qDUMMY plugin&quot; OFF ) # CloudCompare &apos;DUMMY&apos; plugin if (INSTALL_QDUMMY_PLUGIN) project( QDUMMY_PLUGIN ) #load necessary libraries (see qPCV for an example) #add_subdirectory (LIB1) #if the plugin is an &apos;OpenGL filter&apos;, uncomment the line below #set( CC_OPENGL_FILTER ON BOOL) include( ../CMakePluginTpl.cmake ) #set dependencies to necessary libraries (see qPCV for an example) #target_link_libraries( ${PROJECT_NAME} LIB1 ) #include_directories( ${LIB1_INCLUDE_DIR} ) endif() 修改后的CMakeLists.txt文件里面是这样的： cmake_minimum_required(VERSION 3.0) option( INSTALL_QSAF_PLUGIN &quot;Check to install qSAF plugin&quot; OFF ) if (INSTALL_QSAF_PLUGIN) #CloudCompare ‘SAF’ plugin project( QSAF_PLUGIN ) include( ../CMakePluginTpl.cmake ) endif() 剩下的qSAF.h、qSAF.cpp和qSAF.qrc就不一一列出了 修改后变成这样： 使用qmake构建pro文件在终端进入到你的插件的qSAF目录，执行： qmake -project -r CMakeLists.txt 就会在qSAF目录下构建一个项目的pro文件。 导入工程到QT现在把CloudComapre导入到QT， 在CloudComapre-plugins-plugins.pro中，加上自己的插件： 保存刷新后就会在项目上看到了。 pro文件编写由于qmake自动生成的pro文件不适合我们要写的插件，所以要自己修改pro文件。 pro文件的编写可以参考： QT的pro文件编写 里面的常规pro文件就是qSAF的。 里面的路径可以不用修改，具体看你项目的Release生成的位置， 特别注意：指定生成路径中的libs和plugins要正确 完成模板插件框架没错！这就完成了，你的插件已经做出来了！现在可以Run一下或者Debug一下看看啦~ 选中点云，使用qSAF，会这样： 莫慌！这是正常现象，因为你的qSAF具体实现还没有写呢！ 遇到问题1. 编译出错可能原因： qSAF.h、qSAF.cpp和qSAF.qrc这三个文件里面的qDummyPlugin及类似的名字要改为自己的qSAF，如果改错或没改，可能报错。 自己写的代码有错，这个视情况而定 2. 运行的CloudComapre插件上没有你编写的插件的快捷方式可能原因 插件的生成路径出错了，自己插件的pro文件中的plugins指定生成路径要正确。 个性化插件现在来个性化一下我们的插件 在qSAF.h中： // 设置插件的唯一ID Q_PLUGIN_METADATA(IID &quot;cccorp.cloudcompare.plugin.qSAF&quot;) // 设置插件名字 virtual QString getName() const override { return &quot;SAF&quot;; } // 设置插件的描述 virtual QString getDescription() const override { return &quot;Filter the scanning angle in a range of points&quot;; } // 设置插件图标，这个要在 qSAF.cpp 里设置图标路径 virtual QIcon getIcon() const override; // 设置插件要执行的操作（重点） void doAction(); 插件doAction()我们编写插件是要做些事情，在CloudComapre插件中就是在doAction()中实现按下插件SAF后要做的事。 这个函数在qSAF.cpp中，你会发现复制的模板插件的doAction()是这样的（把qDummyPlugin改为qSAF啦）： void qSAF::doAction() { //m_app should have already been initialized by CC when plugin is loaded! //(--&gt; pure internal check) assert(m_app); if (!m_app) return; /*** HERE STARTS THE ACTION ***/ //put your code here //--&gt; you may want to start by asking parameters (with a custom dialog, etc.) //This is how you can output messages m_app-&gt;dispToConsole(&quot;[qSAF] Hello world!&quot;,ccMainAppInterface::STD_CONSOLE_MESSAGE); //a standard message is displayed in the console m_app-&gt;dispToConsole(&quot;[qSAF] Warning: qSAF plugin shouldn&apos;t be used as is!&quot;,ccMainAppInterface::WRN_CONSOLE_MESSAGE); //a warning message is displayed in the console m_app-&gt;dispToConsole(&quot;qSAF plugin shouldn&apos;t be used as is!&quot;,ccMainAppInterface::ERR_CONSOLE_MESSAGE); //an error message is displayed in the console AND an error box will pop-up! /*** HERE ENDS THE ACTION ***/ } 我们要做的就是在 /*** HERE STARTS THE ACTION ***/ 下面写自己的插件代码。 刚才你看的错误信息就是这句： m_app-&gt;dispToConsole(&quot;qSAF plugin shouldn&apos;t be used as is!&quot;,ccMainAppInterface::ERR_CONSOLE_MESSAGE); 这是控制台输出的错误信息。 错误信息(ERR_CONSOLE_MESSAGE)同时在控制台和窗体形式出现，而其他标准信息(STD_CONSOLE_MESSAGE)、警告信息(WRN_CONSOLE_MESSAGE)，则只在控制台显示。 现在删掉/*** HERE STARTS THE ACTION ***/下面的，改为自己的一句： m_app-&gt;dispToConsole(&quot;[qSAF] 程序是从错误开始的！&quot;,ccMainAppInterface::ERR_CONSOLE_MESSAGE); 结果如下： 插件框架完成现在已经完成了插件框架的编写啦。 其实只要使用CloudComapre提供的插件模板qDummyPlugin，改成自己的就可以啦。 现在可以发挥你的想象力，在doAction()里面随心所欲地做各种事情啦。 但是只有框架还不够，要想对点云进行操作，和SAF功能的具体实现，还需要了解CloudComapre中点云的数据结构： CloudComapre插件编写二（数据结构） 如果你对点云数据结构虐它如虐狗，可以戳这里： CloudComapre插件编写三（算法实现）]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CloudCompare</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CloudCompare插件编写二（数据结构）]]></title>
    <url>%2F2017%2F04%2F27%2FCloudCompareSAFPlugin_2_DataStructure%2F</url>
    <content type="text"><![CDATA[唠叨本文分三篇来介绍一个完整的CloudComapre插件的编写教程，分别是插件框架篇、数据结构篇、算法实现篇。 这是第二篇，数据结构篇，你可以根据本文改成自己的插件，待卿临幸。 特别注意：本文的CloudCompare源码构建的是Qt工程并使用Qt Creator开发，并不是Visual Studio。 qSAF源码：Github . qSAF 前文概要在上回中，我们已经实现了插件的框架，现在要在doAction()中写插件的具体实现。 插件需求我们要做的是一个qSAF(Scan Angle Filter)插件，它可以过滤给定范围内点的扫描角度。 也就是用户输入两个角度值，如20度、70度， 过滤输出每个点的扫描角度在大于等于20度、小于等于70度的范围的点云。 需求分析要实现这个功能，我们需要有一个界面，可以让用户输入两个角度，然后获取两个角度值，接着遍历每个点，获取每个点的扫描角度，然后获得角度在大于等于20度、小于等于70度范围的点云，显示输出。 简单地说，就是要： 输入界面 遍历角度 输出点云 1. 输入界面是QT基础；3. 输出点云是CC套路；只有2. 遍历角度有点纠结。 因此本文第二篇主要介绍2. 遍历角度，即介绍点云中点的数据结构。 注意：不同类型文件的数据结构不同，本文以激光雷达文件(.las)来做介绍。 las文件的读入首先，我们从宇宙的起源开始说起…… 额，还是从.las文件的读入开始说起吧~ .las文件的读入首先进过FileIOFilter这个类，判断是雷达文件(.las)后，进入LASFilter类，并从它的loadFile()函数读入。 先看下loadFile()函数声明： virtual CC_FILE_ERROR loadFile(QString filename, ccHObject&amp; container, LoadParameters&amp; parameters) override; 特别注意三个传入参数！我就是忽视了这里才找了好久。。。 QString filename 是点云文件名（包括路径） ccHObject&amp; container 是一个实体（ccHObject），可以添加点云（ccPointCloud） LoadParameters&amp; parameters 是选择读入文件后提示要勾选雷达的哪些信息 然后看下loadFile()函数体 .las文件首先从io流读入，再使用liblas这个外部库存储： liblas::Reader reader(liblas::ReaderFactory().CreateWithStream(ifs)); 这里说下liblas： liblas是用于读取和编写非常常见的LAS LiDAR格式的C/C++库，我们使用它来做对LAS的直接读取。 官网如下： https://www.liblas.org/ 然后把liblas读入的文件进行各种处理和封装，最终封装成ccPointCloud ccPointCloud* loadedCloud = 0; int sfIndex = loadedCloud-&gt;addScalarField(field-&gt;sf); ... loadedCloud-&gt;setName(chunkName); ... loadedCloud-&gt;setMetaData(LAS_SCALE_X_META_DATA, QVariant(lasScale.x)); ... loadedCloud-&gt;addPoint(P); ... 然后通过： container.addChild(loadedCloud); 添加到ccHObject中 所以：点云的信息，都是存储在ccPointCloud中的！ 而扫描角度存储在ccPointCloud的标量域中(ccScalarField) ccPointCloud前面已经说了很多ccPointCloud了，它就是CloudCompare中存储点云的类。 我们看看它的说明 //! A 3D cloud and its associated features (color, normals, scalar fields, etc.) /** A point cloud can have multiple features: - colors (RGB) - normals (compressed) - scalar fields - an octree strucutre - per-point visibility information (to hide/display subsets of points) - other children objects (meshes, calibrated pictures, etc.) **/ 我要的扫描角度就在scalar fields 然而在ccPointCloud没有直接的方法获得众多标量域中的扫描角度 终于在它的父类ChunkedPointCloud中发现了 ChunkedPointCloudccPointCloud的父类ChunkedPointCloud中有如下两个函数： # 通过标量域名字获得其在标量域数组中的索引 int ChunkedPointCloud::getScalarFieldIndexByName(const char* name) const # 通过索引获得特定标量域的指针 ScalarField* ChunkedPointCloud::getScalarField(int index) const 通过这两个函数就可以获得指向扫描角度的指针了，要想访问扫描角度中每个点的值，需要使用ScalarField父类GenericChunkedArray的方法 GenericChunkedArray# 通过每个点的索引访问特定标量域的每个的的值 inline const ElementType* getValue(unsigned index) const LASOpenDlg标量域中扫描角度的名字可以在LASOpenDlg.h中找到 &quot;Scan Angle Rank&quot; 整理下思路 用Scan Angle Rank，通过getScalarFieldIndexByName()获得扫描角度在标量域中的索引 用索引，通过getScalarField()获得扫描角度标量域指针 用指针，通过getValue()获得每个点的值 这样就获取到了每个点的扫描角度值，然后： 比较扫描角度值与用户输入区间的大小，把合适的值存储起来 把合适值封装成点云实体 显示在界面上 上面整理的思路在下篇实现，现在我们已经知道怎么获取点云中扫描角度的值了，那其他信息呢？ 点云其他信息的获取看下在QT的调试信息： 我们可以发现，其实点云的信息都能在ccPointCloud中获取，比如点容量、点数量、点坐标、标量域、颜色值等。 其中，标量域vector中有9项信息，存储的标量域顺序为： [0] Point Source ID [1] Scan Angle Rank [2] Flightline Edge [3] Scan Direction [4] Number of Returns [5] Return Number [6] Time [7] Intensity [8] Classification 至于如何获取每种数据，都有相应的方法实现，不是在ccPointCloud，就是在它的父类中，耐心点总能找到的~ 下篇概要下篇是算法实现篇，主要说了qSAF插件的具体实现，包括上面说的： 输入界面 遍历角度 输出点云 请戳这里： CloudComapre插件编写三（算法实现）]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CloudCompare</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CloudCompare插件编写三（算法实现）]]></title>
    <url>%2F2017%2F04%2F27%2FCloudCompareSAFPlugin_3_Algorithm%2F</url>
    <content type="text"><![CDATA[唠叨本文分三篇来介绍一个完整的CloudComapre插件的编写教程，分别是插件框架篇、数据结构篇、算法实现篇。 这是第三篇，算法实现篇，你可以根据本文改成自己的插件，待卿临幸。 特别注意：本文的CloudCompare源码构建的是Qt工程并使用Qt Creator开发，并不是Visual Studio。 qSAF源码：Github . qSAF 前文概要在上回中，我们知道了点云中扫描角度的存储结构，下面我们来讲qSAF的具体实现。 UI界面新建QT设计器界面类，命名为ccSAFDlg，在ccSAFDlg.ui文件设计简单的界面。 因为我们只需要一个范围，一个确认取消键，所以我把它弄成这样子： doubleSpinBox要设置范围：0.00到90.00，默认值分别设为20.00和70.00。 ccSAFDlg.h： #ifndef CCSAFDLG_H #define CCSAFDLG_H #include &quot;ui_SAFDlg.h&quot; #include &lt;QDialog&gt; namespace Ui { class ccSAFDlg; } class ccSAFDlg : public QDialog, public Ui::ccSAFDlg { Q_OBJECT public: explicit ccSAFDlg(QWidget *parent = 0); protected slots: //! Saves (temporarily) the dialog paramters on acceptation void saveSettings(); }; #endif // CCSAFDLG_H ccSAFDlg.cpp： #include &quot;ccSAFDlg.h&quot; //定义两个静态阈值，并初始化 static double threshold_1 = 20; static double threshold_2 = 70; ccSAFDlg::ccSAFDlg(QWidget *parent) : QDialog(parent), Ui::ccSAFDlg() { setupUi(this); //关联信号槽 connect(buttonBox, SIGNAL(accepted()), this, SLOT(saveSettings())); //初始化设置阈值 doubleSpinBox_1-&gt;setValue(threshold_1); doubleSpinBox_2-&gt;setValue(threshold_2); } void ccSAFDlg::saveSettings() { //OK后重新赋值 threshold_1 = doubleSpinBox_1-&gt;value(); threshold_2 = doubleSpinBox_2-&gt;value(); } 现在界面就做好了。 插件doAction实现至于doAction的实现，点云其中的数据结构，可以参考第二篇，数据结构篇 简单地说，我们需要： 用Scan Angle Rank，通过getScalarFieldIndexByName()获得扫描角度在标量域中的索引 用索引，通过getScalarField()获得扫描角度标量域指针 用指针，通过getValue()获得每个点的值 比较扫描角度值与用户输入区间的大小，把合适的值存储起来 把合适值封装成点云实体 显示在界面上 大体的算法思路上是没有问题的，但是有个纠结的地方，就是是否使用进度条。 实测SAF处理一个雷达文件， 使用进度条耗时：129.1s 不用进度条耗时：3.5s 这种压倒性的差距让我果断砍掉真·进度条，没错！我使用假·进度条，就是不会动的进度条。 这样短时间的处理使用假·进度条，既不会降低处理速度，也不会降低用户体验~ 下面就是完整代码，注释中有真·进度条的实现（[进度条]），但不推荐使用 void qSAF::doAction() { //当插件加载时，m_app应该已经被CC初始化了 assert(m_app); if (!m_app) return; //获取选择的实体 const ccHObject::Container&amp; selectedEntities = m_app-&gt;getSelectedEntities(); //获取选择的实体数量 size_t selNum = selectedEntities.size(); //确保只选择一个实体 if (selNum != 1) { m_app-&gt;dispToConsole(&quot;[SAF] Select only one cloud!&quot;, ccMainAppInterface::ERR_CONSOLE_MESSAGE); return; } ccHObject* ent = selectedEntities[0]; assert(ent); //确保选择的实体是POINT_CLOUD类型 if (!ent || !ent-&gt;isA(CC_TYPES::POINT_CLOUD)) { m_app-&gt;dispToConsole(&quot;[SAF] Select a real point cloud!&quot;, ccMainAppInterface::ERR_CONSOLE_MESSAGE); return; } //从选择的实体中转换成ccPointCloud*类型 ccPointCloud* pc = static_cast&lt;ccPointCloud*&gt;(ent); //获取点云的数量m_count unsigned count = pc-&gt;size(); //初始化阈值变量 static double threshold_1 = 20; static double threshold_2 = 70; double threshold_temp = 0; //显示插件ui窗体 { ccSAFDlg safDlg(m_app-&gt;getMainWindow()); safDlg.doubleSpinBox_1-&gt;setValue(threshold_1); safDlg.doubleSpinBox_2-&gt;setValue(threshold_2); if(!safDlg.exec()) { return; } //存储阈值 threshold_1 = safDlg.doubleSpinBox_1-&gt;value(); threshold_2 = safDlg.doubleSpinBox_2-&gt;value(); } //显示进度条窗体 QProgressDialog pDlg; pDlg.setWindowTitle(&quot;SAF&quot;); pDlg.setLabelText(QString(&quot;Scan Angle Filter\nfrom %1 to %2&quot;).arg(threshold_1).arg(threshold_2)); //[进度条]设置进度条总范围 //pDlg.setRange(0, count); pDlg.setCancelButton(0); pDlg.show(); QApplication::processEvents(); QElapsedTimer timer; //计时开始 timer.start(); ScalarType scanAngle; CCLib::ReferenceCloud rangeAnglerc(pc); //确保 threshold_1 小于 threshold_2 if(threshold_1 &gt; threshold_2) { threshold_temp = threshold_1; threshold_1 = threshold_2; threshold_2 = threshold_temp; } //[进度条]进度条的取消SAF按钮 //bool wasCancelled = false; //获取 Scan Angle Rank 的索引 int scanAngleSFIndex = pc-&gt;getScalarFieldIndexByName(&quot;Scan Angle Rank&quot;); //[重点]遍历每个点的操作 for(unsigned i = 0; i &lt; count; ++i) { //获取每个点的扫描角度 scanAngle = pc-&gt;getScalarField(scanAngleSFIndex)-&gt;getValue(i); //取扫描角度的绝对值 if(scanAngle &lt; 0) { scanAngle = -scanAngle; } //如果扫描角度在给定的阈值范围，则添加它的索引到参考云 if(threshold_1 &lt;= scanAngle &amp;&amp; scanAngle &lt;= threshold_2) { rangeAnglerc.addPointIndex(i); } // //[进度条]重置进度条 // pDlg.setValue(i); // QCoreApplication::processEvents(); // //[进度条]取消SAF处理 // if (pDlg.wasCanceled()) // { // wasCancelled = true; // break; // } } //把 ReferenceCloud 类型克隆成 ccPointCloud 类型 ccPointCloud* rangeAnglepc = pc-&gt;partialClone(&amp;rangeAnglerc); //判断rangeAnglepc是否为空，即所选范围内是否有点 if(!rangeAnglepc) { m_app-&gt;dispToConsole(&quot;[SAF] Failed to extract the range angle subset.&quot;, ccMainAppInterface::ERR_CONSOLE_MESSAGE); return; } //计算SAF后点数所占的百分比和SAF过程所花的时间 m_app-&gt;dispToConsole(QString(&quot;[SAF] %1% of scan angle points are filtered&quot;).arg((rangeAnglerc.size() * 100.0) / count, 0, &apos;f&apos;, 2), ccMainAppInterface::STD_CONSOLE_MESSAGE); m_app-&gt;dispToConsole(QString(&quot;[SAF] Timing: %1 s.&quot;).arg(timer.elapsed() / 1000.0, 0, &apos;f&apos;, 1), ccMainAppInterface::STD_CONSOLE_MESSAGE); //关闭进度条 pDlg.close(); QApplication::processEvents(); // //[进度条]取消SAF // if (wasCancelled) // { // m_app-&gt;dispToConsole(&quot;[SAF] SAF was cancelled&quot;, ccMainAppInterface::STD_CONSOLE_MESSAGE); // return; // } //隐藏原始点云 pc-&gt;setEnabled(false); //添加新的一组DB实体 ccHObject* cloudContainer = new ccHObject(pc-&gt;getName() + QString(&quot;_saf&quot;)); //设置新点云并添加到实体 rangeAnglepc-&gt;setVisible(true); rangeAnglepc-&gt;setName(&quot;SAF Point Cloud&quot;); cloudContainer-&gt;addChild(rangeAnglepc); //添加实体到DB树 m_app-&gt;addToDB(cloudContainer); //刷新 m_app-&gt;refreshAll(); } 效果 结语经过了三篇的学习，终于实现了个完整的插件。 回顾我们学习的路线：插件框架 -&gt; 数据结构 -&gt; 算法实现 我们不仅从中学会了CC插件的编写，也学到了QT的pro文件编写、QT界面设计、CC运作流程、点云数据结构等。 而我在学习这个插件编写的过程收获更多，因为我是看代码两个月，写代码两小时，Debug两天（差不多啦~不要纠结为什么222~） 看代码的过程是非常痛苦的，CC里面大量的模板编程思想，接口设计思想，还有去他继承谁爸爸的爸爸…… 但是期间确实学到很多，以此作为分享，望共勉！]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CloudCompare</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT的pro文件编写]]></title>
    <url>%2F2017%2F04%2F26%2FQTProFile%2F</url>
    <content type="text"><![CDATA[常规pro文件下面是CloudCompare中一个自己写的插件的pro文件， pro文件编写可按照如下方式写。 # 添加QT的模块 QT += widgets \ opengl # 指明让qmake生成哪种makefile文件，app表示应用程序，lib表示库 TEMPLATE = lib # 指明生成的库的名字 TARGET = qSAF # 指明编译依赖路径 DEPENDPATH += .\ # 包含头文件路径 INCLUDEPATH += .\ $$PWD/../ # 工程的头文件路径 HEADERS += qSAF.h \ ../ccStdPluginInterface.h \ ../ccPluginInterface.h \ ../ccMainAppInterface.h \ ccSAFDlg.h # 工程的源文件路径 SOURCES += qSAF.cpp ../ccStdPluginInterface.cpp \ ccSAFDlg.cpp # 工程的资源文件路径 RESOURCES += qSAF.qrc #CC (CloudCompare核心算法库路径) win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lCC_CORE_LIB else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lCC_CORE_LIB else:unix: LIBS += -L$$PWD/../../../Release/libs/ -lCC_CORE_LIB # 包含CC的头文件路径 INCLUDEPATH += $$PWD/../../CC/include # 包含CC的依赖路径 DEPENDPATH += $$PWD/../../CC #qCC_db (CloudCompare数据库路径) win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lQCC_DB_LIB else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lQCC_DB_LIB else:unix: LIBS += -L$$PWD/../../../Release/libs/ -lQCC_DB_LIB INCLUDEPATH += $$PWD/../../libs/qCC_db DEPENDPATH += $$PWD/../../libs/qCC_db # 工程的ui文件路径 FORMS += \ SAFDlg.ui # Mac系统下，则执行括号内的代码 macx { # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../../Release/libs -Wl QMAKE_LFLAGS_DEBUG += -Wl,-rpath,$$PWD/../../../Release/libs -Wl #指定生成路径 DESTDIR = $$PWD/../../../Release/CloudCompare.app/Contents/plugins } # Mac外的其他Unix系统下(Linux)，则执行括号内的代码 unix:!macx{ # linux only # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath=$$PWD/../../../Release/libs -Wl,-Bsymbolic QMAKE_LFLAGS_DEBUG += -Wl,-rpath=$$PWD/../../../Release/libs -Wl,-Bsymbolic #指定生成路径 DESTDIR = $$PWD/../../../Release/plugins } # Windows系统下，则执行括号内的代码 win32 { # windows only }]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ IO 库条件状态及EOF]]></title>
    <url>%2F2017%2F04%2F15%2FCppConditionStateAndEOF%2F</url>
    <content type="text"><![CDATA[文本文件判空问题对于空文本文件的判断问题引起了我对 IO 库中条件状态和 EOF 的探究。 就是这段程序： int vehicle_number; fstream infile; infile.open(&quot;vehicle.txt&quot;, ios::in); if(infile.is_open()) { while(!infile.eof()) { infile &gt;&gt; vehicle_number; ...... } infile.close(); } 它可以打开空文本文件并运行到 while(!infile.eof()) 循环里面。由于是空文本文件，它进入里面会造成一些问题，所以需要对文件进行判空。 EOFEOF（End Of File） 常用于： 文件结束标志 函数出错的返回值 在 C++ IO 库中可用作： 条件状态的判定 现在让我们看看 IO 库中的描述。 IO 库条件状态【表一】IO 库条件状态 状态 含义 strm::iostate strm是一种IO类型。iostream是一种机器相关的整型提供了表达条件状态的完整功能 strm::badbit strm::badbit用来指出流已崩溃 strm::failbit strm::failbit用来指出一个IO操作失败了 strm::eofbit strm::eofbit用来指出流达到了文件结束 strm::goodbit strm::goodbit用来指出流未处于错误状态。此值保证为零 s.eof() 流 s 的 eofbit 置位，则返回 true s.fail() 流 s 的 failbit 或 badbit 置位，则返回 true s.bad() 流 s 的 badbit 置位，则返回 true s.good() 若流 s 处于有效状态，则返回 true s.clear() 将流 s 中的所有条件状态位复位，将流的状态设置为有效。返回void s.clear(flag) 根据给定的 flags 标志位，将流 s 中对于条件状态位复位。 flag 的类型是strm::iostate。返回 void s.setstate(flag) 根据给定的 flags 标志位，将流 s 中对于条件状态位置位。 flag 的类型是strm::iostate。返回 void s.rdstate() 返回流 s 的当前条件，返回值类型为 strm::iostate 【表二】四种条件状态 状态 含义 数值 good() eof() bad() fail() rdstate() ios::goodbit 流状态完全正常 0 1 0 0 0 goodbit ios::eofbit 已达到文件结束 2 0 1 0 0 eofbit ios::badbit 输入（输出）流出现非致命错误，可挽回 1 0 0 1 0 badbit ios::failbit 输入（输出）流出现致命错误，不可挽回 4 0 0 0 1 failbit 我们先看【表一】的关于 EOF 的这两行： 状态 解释 strm::eofbit strm::eofbit用来指出流达到了文件结束 s.eof() 流 s 的 eofbit 置位，则返回 true 这里指出当流读到文件结束时，eofbit 置 1 ，用于标识读取到文件的末尾。 而 eof() 是当 eofbit 置位（置 1）时才返回，并不是读到文件末尾就返回。 所以使用 eof() 读取文件，读到结束标志 EOF 时不会立刻返回 true，只是 eofbit 置位，下次调用 eof() 才返回 true。 文本文件判空问题的解释现在就可以解释最初的问题了，让我们回过头看看。 当程序第一次运行到 while(!infile.eof()) 时，infile.eof() 读到文件末尾的 EOF，但并不是立刻返回 true，只是 eofbit 置位，所以 infile.eof() 还是 false 的状态，所以会进入 while 循环。 文本文件判空问题的解决 把流对象状态当做条件使用 if(infile.is_open()) { while(infile &gt;&gt; vehicle_number) { ...... } } 使用 peek() istream::peek() 用于读取并返回流的下一个字符（返回值为 char 类型），但并不读取该字符到输入流中，即流指针依然指向原来位置，并不后移。 if(infile.is_open()) { while(infile.peek() != EOF) { infile &gt;&gt; vehicle_number; ...... } } 重复读入非空文本文件最后一个字符问题经过上面的解释，我们已经知道了文本文件如何判空。但由于 EOF 的锅，若用 while(!infile.eof()) 还会导致重复读入非空文本文件最后一个字符的问题。 看下面这段代码： char c; fstream infile; infile.open(&quot;test.txt&quot;, ios::in); if(infile.is_open()) { while(!infile.eof()) { infile &gt;&gt; c; cout &lt;&lt; c; } } infile.close(); 和文本文件判空问题的代码相似，只是读入字符存储到 char 类型变量中，并把其输出。 然后我们在 test.txt 中保存 abc 这三个字符。 运行的结果是： abcc 即 while(!infile.eof()) 重复执行了最后一趟，多输入了字符 c 。 这个问题和文本文件判空问题的解决办法一样，都是使用 peek() 或者把流对象当做 while 的条件来解决。 总结 使用 eof() 读取文件，读到结束标志 EOF 时不会立刻返回 true，只是 eofbit 置位，下次调用 eof() 才返回 true。 只有一个流处于无错状态时，我们才可以对它读写数据。因此代码通常应该在使用一个流之前检查它是否处于良好状态。]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos 7 挂载 NTFS 分区]]></title>
    <url>%2F2017%2F03%2F29%2FCentos7NTFS%2F</url>
    <content type="text"><![CDATA[NTFS-3G安装使用 NTFS-3G 实现，可以挂载 NTFS，还可以挂载 HFS+ 等，以下是在 Centos 7 下安装 NTFS-3G 及挂载 NTFS 分区 wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo sudo yum update sudo yum install ntfs-3g 查看分区fdisk -l 挂载# d、e、f改成你想要挂的盘符名字 mkdir /mnt/windows/d mkdir /mnt/windows/e mkdir /mnt/windows/f # d、e、f改成你想要挂的盘符名字，sdb3这些改为要挂的分区 mount -t ntfs-3g /dev/sdb3 /mnt/windows/d mount -t ntfs-3g /dev/sdb4 /mnt/windows/e mount -t ntfs-3g /dev/sdb5 /mnt/windows/f 卸载umount /mnt 设置开机自动挂载sudo vim /etc/fstab #只读式挂载： /dev/sda1 /mnt/windows/c ntfs-3g ro,umask=0222,defaults 0 0 #读写式挂载： /dev/sda1 /mnt/windows/c ntfs-3g rw,umask=0000,defaults 0 0 #或者： /dev/sda1 /mnt/windows/c ntfs-3g defaults 0 0 设置后开机无法启动（无法挂载）网上很多教程都是如上几步就好了~ 然而我的无法开机。 如下图： 这样应该需要输入root密码，用root账户登录修复模式， 然后 vim /etc/fstab 删除刚刚添加的东西， reboot 就能进入系统了 所以之前之前忙活的都没用了？ 后来试了下原来 mount -t ntfs-3g /dev/sdb3 /mnt/windows/d 这句本身就无法挂载！ 然后可以通过 sudo mount -o ro /dev/sdb3 /mnt/windows/d 挂载，但是只能通过终端访问，就是下面这个👇 其他问题无法挂载的解决办法实现了只能在终端访问 #创建挂载点 mkdir /mnt/windows/d mkdir /mnt/windows/e mkdir /mnt/windows/f #挂载分区 sudo mount -o ro /dev/sdb3 /mnt/windows/d sudo mount -o ro /dev/sdb4 /mnt/windows/e sudo mount -o ro /dev/sdb5 /mnt/windows/f #添加上面挂载分区到这里面 sudo vim /etc/rc.d/rc.local #更改权限 chmod +x /etc/rc.d/rc.local Thankshttp://www.cnblogs.com/gbyukg/archive/2011/11/02/2232343.html http://www.jianshu.com/p/f578b575fcaa http://askubuntu.com/questions/462381/cant-mount-ntfs-drive-the-disk-contains-an-unclean-file-system https://www.techbrown.com/mount-ntfs-file-system-centos-7-rhel-7.shtml]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下QT编译输出路径错误：ld unknown option ...]]></title>
    <url>%2F2017%2F03%2F26%2FMacQTCompilerOutputPathError%2F</url>
    <content type="text"><![CDATA[ERROR: ld unknown option rpathMac指定qmake的生成路径时，用 -Wl,-rpath,$$PWD/.. 而不是 -Wl,-rpath=$$PWD/.. 如下： macx{ # linux only # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../Release/libs -Wl QMAKE_LFLAGS_DEBUG += -Wl,-rpath,$$PWD/../../Release/libs -Wl # 指定生成路径 DESTDIR = $$PWD/../../Release } Linux则用 -Wl,-rpath=$$PWD/.. unix:!macx{ # linux only # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath=$$PWD/../../Release/libs -Wl,-Bsymbolic QMAKE_LFLAGS_DEBUG += -Wl,-rpath=$$PWD/../../Release/libs -Wl,-Bsymbolic # 指定生成路径 DESTDIR = $$PWD/../../Release/libs } ERROR: ld unknown option BsymbolicMac 不支持-Bsymbolic，所以不能这样： QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../Release/libs -Wl,-Bsymbolic 应该删去-Bsymbolic，如下： QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../Release/libs -Wl]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>链接装载库</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CloudCompare功能概要]]></title>
    <url>%2F2017%2F03%2F21%2FCloudCompareFunction%2F</url>
    <content type="text"><![CDATA[File open：打开 save：保存 Global Shift settings：设置最大绝对坐标，最大实体对角线 Primitive Factory：对点云进行原始加工，改变原始点云的形状 3D mouse：对3D鼠标（如3Dconnexion）的支持 Close all：关闭所有打开的实体 Quit：退出 Edit： Clone：克隆选中的点云 Merge：合并两个或者多个实体。可以合并点云（原始云会被删除）；可以合并网格（原始网不会修改，CC会创建一个新的网格结构） Subsample：采集原始点云的子样本，可以用随机、立体、基于八叉树的方式采集，子样本会保持原始点云的标量、颜色、法线等性质。 Apply Transformation：可以对选中的实体做变换（4*4矩阵、轴线角，欧拉角） Multiply / Scale：让选中实体的坐标倍增。 Translate / Rotate (Interactive Transformation Tool)：可以相对于另外一个实体或者坐标系移动选中的实体 Segment (Interactive Segmentation Tool)：通过画2D多边形分隔选中的实体 Crop：分割一个或多个在3D-Box里面的点云。 Edit global shift and scale：进行全局变换和和比例缩放。 Toggle (recursive)：用于控制键盘的快捷键。 Delete：删除选中的实体。 Colors &gt; Set Unique：为所选实体设置唯一一个的颜色 Colors &gt; Colorize：为所选实体着色，具体表现为分别用所选颜色乘以当前颜色的RGB而得到新的颜色 Colors &gt; Levels：通过调整颜色的柱形图变色，类似于Photoshop的Levels方法 Colors &gt; Height Ramp：为所选实体设置颜色渐变（线形、梯形、环形） Colors &gt; Convert to Scalar Field：将当前的 RGB 颜色字段转换为一个或几个标量字段 Colors &gt; Interpolate from another entity：在所选实体中插入另外一个实体的颜色 Colors &gt; Clear：移除所选实体的颜色域 Normals &gt; Compute：计算所选实体的法线 Normals &gt; Invert：反转所选实体的法线 Normals &gt; Orient Normals &gt; With Minimum Spanning Tree：用同样的方法重新定位点云的全部法线（最小生成树） Normals &gt; Orient Normals &gt; With Fast Marching：用同样的方法重新定位点云的全部法线（快速行进法） Normals &gt; Convert to &gt; HSV：将云的法线转换到 HSV 颜色字段 Normals &gt; Convert to &gt; Dip and Dip direction SFs：转换点云的法线到两个标量域 Normals &gt; Clear：为选定的实体移除法线 Octree &gt; Compute：强制计算给定实体的八叉树 Octree &gt; Resample：通过代替每个八叉树单元内的所有点来重新取样 Mesh &gt; Delaunay 2.5D (XY plane)：计算点云在xy平面上的2.5D三角剖分（Delaunay 2.5D triangulation，德洛内2.5D三角算法） Mesh &gt; Delaunay 2.5D (best fit plane)：计算点云在最佳平面的2.5D三角剖分（Delaunay 2.5D triangulation，德洛内2.5D三角算法） Mesh &gt; Convert texture/material to RGB：将选定网格的网格材料和纹理信息转换为逐个点的 RGB 字段 Mesh &gt; Sample points：在一个网格中随机取样 Mesh &gt; Smooth (Laplacian)：平滑一个网格（Laplacian smoothing，拉普拉斯平滑算法） Mesh &gt; Subdivide：细分网格，此算法递归细分网格三角形，直到他们的表面细分到用户指定值之下。 Mesh &gt; Measure surface：测量网格的总体表面积和每个三角形的平均表面积，在控制台输出 Mesh &gt; Measure volume：测量闭合网格的体积，在控制台输出 Mesh &gt; Flag vertices：检查网格的基本特性，为每个网格样本做标志：0 = normal，1 = border，2 = non-manifold Mesh &gt; Scalar field &gt; Smooth：平滑网格顶点相关联的标量场。此方法与高斯滤波（Gaussian Filter）相反。运用qPCV插件后，此方法特别有用 Mesh &gt; Scalar field &gt; Enhance：增强与网格顶点相关联的标量场。运用qPCV插件后，此方法特别有用 Sensors &gt; Edit：修改指定传感器内外在参数 Sensors &gt; Ground Based Lidar &gt; Create：创建’Ground Based Lidar’ (= TLS)传感器实体，附加到所选的点云 Sensors &gt; Ground Based Lidar &gt; Show Depth Buffer：显示选中的Ground Based Lidar的深度 Sensors &gt; Ground Based Lidar &gt; Export Depth Buffer：以ASCII文件的形式导出选中的Ground Based Lidar传感器的深度图 Sensors &gt; Camera Sensor &gt; Create：创建影像传感器 Sensors &gt; Camera Sensor &gt; Project uncertainty：输出影像模块不确定的点云，输出不确定的x、y、z、3D信息 Sensors &gt; Camera Sensor &gt; Compute points visibility (with octree)：统计选中影像传感器选中的点云。0=NOT VISIBLE，1=VISIBLE Sensors &gt; View from sensor：更改当前的 3D 视图影像设置以匹配选定的传感器的设置 （用泡沫视图模式） Sensors &gt; Compute ranges：计算全部点（对于任何点云）相对于指定传感器的范围 Sensors &gt; Compute scattering angles：计算全部点（对于任何有法线的云）相对于选中传感器分散的角度 Scalar fields &gt; Show histogram：对当前选中的实体显示有效标量域的柱形图 Scalar fields &gt; Compute statistical parameters：计算统计分布（高斯分布、威布尔分布） Scalar fields &gt; Gradient：计算标量域的梯度 Scalar fields &gt; Gaussian filter：通过应用一个立体高斯滤镜，平滑一个标量域 Scalar fields &gt; Bilateral filter：用双边滤镜平滑一个标量域 Scalar fields &gt; Filter by Value：用标量值筛选选定的云 Scalar fields &gt; Convert to RGB：将有效的标量场转化为RGB颜色域 Scalar fields &gt; Convert to random RGB：将有效的标量场转化为随机的RGB颜色域 Scalar fields &gt; Rename：对选中实体重命名有效的标量域 Scalar fields &gt; Add constant SF：用一个常数添加一个标量域 Scalar fields &gt; Add point indexes as SF：用点索引的方式为所选点云创建一个新的标量域 Scalar fields &gt; Export coordinate(s) to SF(s)：导出坐标到标量域 Scalar fields &gt; Set SF as coordinate(s)：为选中的点云设置标量域的坐标 Scalar fields &gt; Arithmetic：可以对在同一个点云的两个标量域进行标准运算（+，-，*，/），或者对单个标量域进行函数运算 Scalar fields &gt; Color Scales Manager：色阶管理，可以管理和创建新色域 Scalar fields &gt; Delete：对选中的实体删除有效的标量域 Scalar fields &gt; Delete all (!)：对选中的实体删除全部的有效标量域 Tools： Level：可以选择三个点确定一个平面来操作 Point picking：可以选择一个、两个、三个点来得到各种信息，如点的坐标、RGB、标量值、距离、角度等信息（尤其是两点间的距离） Point list picking：可以选择多个点创建一个点列表，可以输出为一个文件、一个新点云、一个折线 Clean &gt; Noise filter：类似于qPCL插件的S.O.R.滤镜，但又更多功能 Projection &gt; Unroll：展开圆柱或圆锥体的点云成一个平面 Projection &gt; Rasterize：栅格化点云（转化为2.5D网格），然后可以导出为一个新点云或者一个光栅图像 Projection &gt; Contour plot to mesh：可以把一组折线转化为网格，输出边缘轮廓线 Projection &gt; Export coordinate(s) to SF(s)：导出坐标到标量域 Registration &gt; Match bounding-box centers：调整所有选中的实体，让它们的中心在一个地方 Registration &gt; Match scales：匹配所有选中实体的规模 Registration &gt; Align (point pairs picking)：在两个实体中挑选至少三个对应的点来对齐两个实体 Registration &gt; Fine registration (ICP)：自动精确地融合两个实体。前提是：①两个云大体上相融；②表现为同样的对象或者至少有同样的形状 Distances &gt; Cloud/Cloud dist. (cloud-to-cloud distance)：计算两个点云之间的距离 Distances &gt; Cloud/Mesh dist. (cloud-to-mesh distance)：计算点云和网格之间的距离 Distances &gt; Closest Point Set：计算两个点云之间最近的点的集合 Statistics &gt; Local Statistical Test：可以以标量域的局部统计为基础进行分割和过滤点云 Statistics &gt; Compute Stat. Params：计算统计分布（高斯分布、威布尔分布） Segmentation &gt; Label Connected Components：设置最小距离，把所选的云分割成更小的部分，每一部分相互连接 Segmentation &gt; Cross Section：用户可以定义一个裁剪框，可调整框的范围和方向，来裁剪点云。可以用来：①在一个或多个维度重复分割过程；②获取多边形的轮廓 Segmentation &gt; Extract Sections：可以在一个点云的顶部画或者导入多边形来提取截面和轮廓 Fit &gt; Plane：匹配点云中的一个平面和输出各种信息，如拟合 RMS、 垂直平面、地质的倾角、倾角方向值等 Fit &gt; Sphere：适配点云中的一个球体 Fit &gt; 2D Polygon：适配点云中的二维多边形 Fit &gt; Quadric：适配点云中的2.5D曲面 Other &gt; Density：估量一个点云的密度 Other &gt; Curvature：估量一个点云的曲率 Other &gt; Roughness：估量一个点云的粗糙程度 Other &gt; Remove duplicate points：通过设置两点之间最小距离来删除重复的点 Display： Full screen：全屏 Refresh：刷新，强制刷新有效的3D视图的内容（OpenGL图形重绘） Toggle Centered Perspective：在正交视图和对象中心视图模式中切换 Toggle Viewer Based Perspective：在正交视图和透视图中切换 Lock rotation about vert. axis：锁定围绕Z轴的影像旋转 Enter bubble-view mode：进入泡沫视图模式 Render to File：可以渲染当前的3D视图成一个图像文件（支持多数标准文件格式），还可以缩放以适应更大分辨率的屏幕 Display settings：对各种显示进行设置：颜色和材质、色阶、标签、其他 Camera settings：影像设置 Save viewport as object：保存当前3D视图的可视体的参数（影像位置和方、透视状态）为一个可视实体，这个实体自动地添加DB树的根 Adjust zoom：调整缩放比例 Test Frame Rate：测试帧速率，让有效的3D视图在一个较短时间旋转从而估量平均帧数，结果在控制台显示 Lights &gt; Toggle Sun Light：切换太阳光 Lights &gt; Toggle Custom Light：切换自定义的光 Shaders and Filters &gt; Remove filter：禁用任何活动的着色器或者OpenGL过滤器 Active scalar field &gt; Toggle color scale：为所选活动的实体切换色阶 Active scalar field &gt; Show previous SF：改变当前所选对象的标量域，激活先前的标量域 Active scalar field &gt; Show next SF：改变当前所选对象的标量域，激活下一个的标量域 Console：控制台（显示/隐藏） Toolbars：工具栏，包括主工具栏、标量域、视图、插件、GL滤镜 Reset all GUI elements：退出钱自动存储当前GUI信息（位置和工具栏的可见性等），可以恢复原始配置 Plugins：Standard plugins： qHPR (Hidden Point Removal)：如果点云是闭合曲面，则可以过滤（删除）掉通过当前3D影像不能看到的云 qPCL (Point Cloud Library Wrapper)：有PCL库一些方法的接口，主要包括：①计算法线和曲率②异常点和噪声点的去除③平滑点云（移动最小二乘法） qPCV (ShadeVis / Ambient Occlusion)：计算点云的明亮度，类似于光线来自于对象周围的半球或球体（可以自定义光线距离） qPoissonRecon (Poisson Surface Reconstruction)：Poisson表面重建，用三角网络生成算法构建的简单的表面 qRansacSD (RANSAC Shape Detection)：随机抽样一致形状检测，运用自动形状检测算法的简单接口 qSRA (Surface of Revolution Analysis)：计算一个点云和一个假定旋转平面之间的距离（旋转平面用2D轮廓定义），距离计算好后，用户可以创建一个偏差的2D图或者圆柱或圆锥的投影 qCANUPO (Point Cloud Classification)：可自动对点云进行分类，也可以手动分类 qM3C2 (Robust C2C Distances Computation)：用独特的方法计算两个点云之间的有向（稳健）距离 qCork (Boolean Operations on Meshes)：可以执行网格中的布尔操作（也称CSG = 构造实体几何），它基于Cork库 qAnimation：动画渲染插件 qFacets：可以从点云中自动提取二维切面，以它们的垂直距离分开 qCSF (Cloth Simulation Filter)：基于布模拟滤波算法，能实现地面点与非地面点的分离，去除非地面点 qCompass：简单地实现点云中地质结构的它的轨迹的数字化 qBroom (qVirtualBroom)：高效地扫描和清理 qHoughNormals：计算法法线 qGMMREG：对小型实体的非刚性云的匹配 qLAS_FWF：这个插件可以读写标准雷达文件，可以在命令模式下打开LAS 1.3+文件 qPoissonRecon：可以让输入的点云颜色映射到成网格（快速直接地分配到颜色接近输入点颜色的网格顶点） OpenGL ‘shaders’ plugins： qEDL (Eye Dome Lighting)：实时底纹滤镜，用来在空白的点云或者网格中增强少量特质（除了几何信息外，它不依赖于其他信息） qSSAO (Screen Space Ambient Occlusion)：实时底纹滤镜，与环境相似的遮挡 qBlur：一个简单的模糊处理滤镜，主要用于开发人员的演示 Deprecated qKinect (Point Cloud Acquisition with a Kinect)：可以用Kinect设备获取（有色的）点云 3D Views： New：创建3D视图 Close：关闭3D视图 Close All：关闭所有3D视图 Tile：共享的所有 3D 视图之间的显示空间 Cascade：用串联的方式重新排列所有 3D 视图 Next：激活顺序创建的下一个3D视图 Previous：激活顺序创建的上一个3D视图 Help： Help：帮助文档 About：CloudCompare版本信息 About Plugins：插件信息 Thanks： CloudCompare Documentation CloudCompare Wiki Wikipedia]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CloudCompare</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile 问题及解决]]></title>
    <url>%2F2017%2F03%2F13%2FMakefileIssue%2F</url>
    <content type="text"><![CDATA[问题一makefile文件的clean出错 解决clean下面的那句命令没有缩进，应该用[Tab]缩进 小结 利用 Google、stackoverflow 等含金量高的问题解决平台 注意语法规范 问题二 解决newhello:hello.o hello_fn.o 中的newhello应该写成hello，应该与hello.c中的名字一样 小结 注意编译运行的文件名]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm2 + OhMyZsh + agnoster + Powerline + solarized = 漂亮的Mac终端]]></title>
    <url>%2F2017%2F03%2F11%2FFancyMacTerminal%2F</url>
    <content type="text"><![CDATA[唠叨一下自从装了黑苹果后一直用着 Mac 自带的终端（Terminal），相比 Windows 的终端根本无法同台竞技！毕竟 Mac 是基于 Unix 嘛~ 对开发友好太多了。 就是下面这个家伙了👇 本来没觉得什么，直到我看到它👇 颜值碾压，有木有！ 所以就着手折腾了…… iTerm2iTerm是一个非常好的终端模拟器，官网地址：http://iterm2.com/，需要下载它。 zshzsh 是一款强大的虚拟终端，是 Oh My Zsh 的爸爸，所以需要先装它。 在命令行输入： zsh --version 如果输入zsh的当前版本号就说明装好了，一般Mac自带有的 如果没装则需要输入： brew install zsh zsh-completions 这是用Homebrew装，需要Mac上有Homebrew，它的网站：https://brew.sh/ Oh My ZshOh My Zsh 是基于 zsh 的一个扩展工具集，它提供了丰富的扩展功能 它可以通过curl或者wget来安装 via curl sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; via wget sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 装好之后就可以换到 agnoster 主题，就是之前看到的那张颜值主题，Oh My Zsh 一般自带有这个主题。 可以看看它的默认主题： ls ~/.oh-my-zsh/themes 需要修改主题只需： vim ~/.zshrc 然后把里面 ZSH_THEME 的值改为 ZSH_THEME=&quot;agnoster&quot;，保存退出 （点击这里还有各种主题，任君翻牌~） 应用配置： chsh -s /bin/zsh 重启 iTerm2 然后你会惊喜地发现…… 和颜值主题并不一样！ 难道官方坑爹？ 震惊！oh-my-zsh 竟然做出这种事！ 嘛~ 原来少了 Powerline 的字符集 PowerlineGit 下来安装： git clone git@github.com:powerline/fonts.git cd fonts ./install.sh 然后到 iterm2 配置，设置字体为Roboto Mono for Powerline： 这样就可以有颜值图的效果了~ 然而终端下的 vim 编辑器还是一种颜色~ 作为一个追求完美的 geek 怎能容许此等瑕疵呢！ 所以就继续捣鼓 solarized 配色。 solarizedSolarized 是个很牛逼的配色项目，主流OS、IDE、Editor都有它影子。 # git下Solarized 的源码 git clone git://github.com/altercation/solarized.git # 进入文件夹 cd solarized/vim-colors-solarized/colors #下面可能要管理员权限 sudo mkdir -p ~/.vim/colors sudo cp solarized.vim ~/.vim/colors/ # 创建.vimrc文件 sudo vim ~/.vimrc # 把下面这三行复制进去 syntax enable set background=dark colorscheme solarized 然后保存 .vimrc, 退出 之后打开用 vim 打开文件就是这种效果了： Thanks iTerm2 robbyrussell/oh-my-zsh powerline/fonts altercation/solarized]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 简易入门教程]]></title>
    <url>%2F2017%2F01%2F25%2FMarkdownTutorial%2F</url>
    <content type="text"><![CDATA[自己整理的 Markdown 简介、编辑器推荐、语法、特征等，是 Markdown 的简易入门教程 目录 概述 简介 官方文档 Markdown编辑器 初级语法 标题 粗体和斜体 段落和换行 分隔线 引言 列表 无序列表 有序列表 代码 行内代码块 段落代码块 链接 网址链接 图片链接 指定图片宽高 用图床获取外链 进阶语法 标签 目录 表格 脚注 公式 流程图 序列图 其他 兼容HTML 特殊字符自动转换 反斜杠 自动链接 感谢 概述 简介 Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia等网站，如各大博客平台：WordPress、Drupal、简书等。 官方文档 Markdown: Syntax Markdown 语法说明 (简体中文版) Markdown编辑器 在线编辑器 dillinger——漂亮强大，支持md, html, pdf 文件导出。 简书——非常漂亮的博客平台，可以自动备份，直接拖入图片。 Windows MarkdownPad——一款全功能的编辑器，被很多人称赞为windows 平台最好用的markdown编辑器。 MarkPad——开源软件，可以直接在你的博客或者 GitHub 中打开、保存文档，直接将图片粘贴到 Markdown 文档中。 Cmd Markdown——作业部落出品，全平台并支持Web端 Mac Mou——简洁优雅，免费又好用，中文兼容性好。 Typora——极致简洁，自定义皮肤。 MacDown——简洁优雅，开源免费。 Ulysses——文字写作推荐。 多平台 Atom——github出的编辑器，支持各种编程语言，可装Markdown插件。 sublimetext——专业编辑器，支持各种编程语言。 初级语法 标题 Markdown 支持两种标题的语法，类 Atx 和类 Setext 形式。 Atx（注意#后面有个空格） # 一级标题 ## 二级标题 ### 三级标题 Setext（-与=数目任意，最好三个及以上，比较直观） 一级标题 ====== 二级标题 ------ 粗体和斜体 粗体 **这是粗体** __这是粗体__ 斜体 *这是斜体* _这是斜体_ 段落和换行 第一种写法（上图的这是第一段），直接敲两个回车键即可 这是第一段 这是第二段 第二种写法（上图的这是第二段），在写完一段后敲两个空格，然后回车写下一段 这是第二段 这是第三段 第三种写法（上图的这是第三段），在写完一段后用HTML的语法：&lt;br /&gt;作为换行，然后写下一段 这是第三段&lt;br /&gt;这是第四段 这是第三段&lt;br /&gt; 这是第四段 分隔线 可以在一行中用三个及以上的星号、减号、等于号、底线来建立分隔线，行内不能有除空格外的其他东西，注意莫被打脸。 (≖ ‿ ≖)✧ *** --- === ___ 引言 &gt; 我想只用一个 “&gt;” 号来写一个多行的引用，所以在扯鸡巴蛋地码字占空间，好像差不多了吧，嗯嗯~ --- &gt; 还有一种写法就是每一行都用一个 “&gt;” 号 &gt; 这样写比较美观一点 --- &gt; &gt; 另外一种就是嵌套引用，就像我一样，用两个“&gt;” 列表 无序列表 无序列表可以在每行开头用星号、加号、减号来表示，也可以三者混合一起，推荐使用相同的字符，避免混乱。 * 一朵百合花 * 两朵百合花 * 三朵百合花 有序列表 有序列表用数字接着一个英文句点来表示，数字可无序，但还是推荐使用1.、2.，避免混乱。 1. 一朵百合花 2. 两朵百合花 3. 三朵百合花 代码 行内代码块 I am a `code` I am a `` ` `` 段落代码块 #### 第一种 int main() { printf(&quot;我是个段落代码块&quot;); return 0; } 另外，可以用三个反引号和语言名，作为标记代码所使用的语言 我的 Mou 编辑器不能识别 (ノ▼Д▼)ノ 链接 网址链接 网址链接有两种形式：行内式、参考式。 不管是哪一种，链接文字都是用 [方括号] 来标记，双引号&quot;&quot;的title可写可不写。 行内式 [huihut](https://huihut.github.io/) [huihut](https://huihut.github.io/ &quot;huihut&quot;) [huihut](https://huihut.github.io/ &apos;huihut&apos;) 参考式 一般写法 [huihut][1] [1]: https://huihut.github.io/ 隐式链接标记——可省略id，只需要[text]与下面[方括号]内容相同即可 [Google][] [Google]: http://google.com/ 拓展 这里的链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： [text][a] [text][A] 链接 title 可以用双引号、单引号、圆括号包起来，因此，下面这三种链接的定义都是相同： [1]: https://huihut.github.io/ &quot;title&quot; [1]: https://huihut.github.io/ &apos;title&apos; [1]: https://huihut.github.io/ (title) 特别注意：Markdown.pl 1.0.1 会忽略单引号包起来的链接 title 图片链接 图片链接与上面的网址链接类似，同样有两种形式：行内式和参考式，只不过图片链接在前面加上一个感叹号!，在此不做累述。 行内式 ![huihut](http://huihut-img.oss-cn-shenzhen.aliyuncs.com/H_ya.png) 参考式 ![谷歌][1] [1]: https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_120x44dp.png &quot;Google&quot; 指定图片宽高 Markdown 一般不支持指定图片的宽高，若要指定宽高可以使用普通的 &lt;img&gt; 标签 &lt;img src=&quot;./xxx.png&quot; width = &quot;100&quot; height = &quot;100&quot; alt=&quot;title&quot; align=center /&gt; 如果需要居中可以在外围包围div标签 &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;xxx.png&quot; width = &quot;100&quot; height = &quot;100&quot; alt=&quot;title&quot; align=center /&gt; &lt;/div&gt; 使用支持指定图片大小的 Markdown 编辑器，如 Mou ![](xxx.png =100x100) 用图床获取外链 网上有许多图床，这里推荐两个 七牛图床 和 极简图床。 七牛图床 极简图床 进阶语法 标签 方法一 title: Markdown 简易入门教程 date: 2017-01-25 1:45:50 tags: Markdown categories: 技术 方法三 tags: - Markdown - 语言 categories: - 技术 方法三 tags: [Markdown,语言] categories: [技术] 目录 方法一 这种目录其实是用 HTML 加 Markdown的链接 实现，分为两个部分，目录部分和标题部分。 目录部分——实质是链接，链接的[地址]填需要跳转到的标题的id属性（自定义）。 [跳到标题一](#title1) 标题部分——实质是HTML的标题标签，标签里面的id属性等于待跳转的目录的[地址]。 &lt;h1 id=&quot;title1&quot;&gt;标题一&lt;/h1&gt; 方法二 这种方法非常简单，就是直接添加 [TOC]，标题1~6样式的内容会被提取出来作为目录，然而有些编辑器不能使用这功能，如 Mou 不能使用。我是在有道云笔记的 Markdown 中截图的。 [TOC] # 标题一 …… ## 标题二 …… ### 标题三 这里有个jQuery插件，貌似可以让Markdown生成目录： https://github.com/i5ting/i5ting_ztree_toc 表格 表格一般这样子写，这应该是最简单的写法了 id | name | score --- | --- | --- 001 | Mark | 90 002 | Ford | 80 003 | Alan | 95 还有就是对齐了，用:对齐，:写在在---的左边就是左对齐，右边就是右对齐，两边都写就是居中。 |long_long_id|long_long_name|long_long_score| | --- | :---: | ---: | | 001 | Mark | 90 | | 002 | Ford | 80 | | 003 | Alan | 95 | 脚注 这是脚注一[^1] [^1]: 脚注一 公式 方法一：使用Google Chart &lt;img src=&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl=\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}&quot; style=&quot;border:none;&quot;&gt; 方法二：使用forkosh &lt;img src=&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl=\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}&quot; style=&quot;border:none;&quot;&gt; 方法三：使用codecogs &lt;a href=&quot;https://www.codecogs.com/eqnedit.php?latex=x=\frac{-b\pm&amp;space;\sqrt{b^{2}-4ac}}{2a}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://latex.codecogs.com/gif.latex?x=\frac{-b\pm&amp;space;\sqrt{b^{2}-4ac}}{2a}&quot; title=&quot;x=\frac{-b\pm \sqrt{b^{2}-4ac}}{2a}&quot; /&gt;&lt;/a&gt; 方法四：使用MathJax引擎——先加载脚本&lt;script&gt;，后解析公式。 &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt; $$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$ 流程图 像流程图这种复杂的功能不推荐在 Markdown 中使用，因为很多编辑器都不支持，我使用了几个编辑器都不能生成流程图，所以上图是在为知笔记官方 Markdown 新手指南中找到的。 123456789st=&gt;start: Starte=&gt;end: Endop1=&gt;operation: My Operationsub1=&gt;subroutine: My Subroutinecond=&gt;condition: Yes or No?io=&gt;inputoutput: catch something...st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1 更多关于流程图的语法说明： https://github.com/adrai/flowchart.js 序列图 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 更多关于时序图的语法说明： https://github.com/bramp/js-sequence-diagrams 其他语法 兼容HTML Markdown 可以和 HTML 混编，甚至可以完全用 HTML 语法来写。要注意在 HTML 标签中的 Markdown 代码是不起作用的。 &lt;font color=&apos;blue&apos; style=&apos;font-size:30px&apos;&gt;蓝色&lt;/font&gt; &lt;div&gt; # HTML 标签里面的 Markdown 语法不起作用 **你看我没有变粗** &lt;/div&gt; 特殊字符自动转换 HTML 语法——在 HTML 中所有&lt;和&amp;都要转换，包括链接（URL） 用 &amp;lt; 表示 &lt;——起始标签 用 &amp;amp; 表示 &amp; ——标记 HTML 实体 Markdown 语法——Markdown 则会自动转换 反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号。如： *literal asterisks* 可用 \*literal asterisks\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 自动链接 网址自动链接 &lt;https://huihut.github.io/&gt; 电子邮件自动链接 &lt;huihut@outlook.com&gt; 感谢 Markdown: Syntax Markdown 语法说明 (简体中文版) Markdown——入门指南 Markdown语法手册 好用的Markdown编辑器一览 markdown中插入图片怎么定义图片的大小或比例？ Markdown进阶语法整理 为知笔记 Markdown 新手指南 Markdown中插入数学公式的方法 i5ting/i5ting_ztree_toc flowchart.js adrai/flowchart.js js-sequence-diagrams bramp/js-sequence-diagrams]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyCharm自动安装pymysql包失败]]></title>
    <url>%2F2017%2F01%2F21%2FPyCharmInstallPymysqlFail%2F</url>
    <content type="text"><![CDATA[问题描述：在PyCharm中新建Web2Py项目后提示没有pymysql，自动安装失败，如图： 解决方案：1. 安装pip在终端输入 pip -V 如果显示版本路径，就说明pip已经安装了如果没有安装pip则需要在终端安装 ①使用脚本安装pip： 各平台（管理员运行）： python get-pip.py ②使用包管理器安装pip： Mac： sudo easy_install pip Debian &amp; Ubuntu: sudo apt-get install python-pip Fedora: sudo yum install python-pip 2. 安装pymysqlpip install pymysql 3. 正常情况下以上两步就行了。然而我的项目中依然提示没有pymysql，结果发现只是Python版本选错了(ノ▼Д▼)ノ我pymysql是安装到Python2.7，而PyCharm项目是用Python2.6所以就到Preferences &gt; Project Interpreter中调成Python2.7就行了， Thanks http://stackoverflow.com/questions/36956124/permision-issues-while-using-and-installing-python-packages]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
